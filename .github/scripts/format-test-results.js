const fs = require('fs');
const path = require('path');

/**
 * Formats Playwright test results into GitHub-friendly markdown
 * @param {string} testResultsPath - Path to the test-results.json file
 * @param {string} junitPath - Path to the junit-report.xml file
 * @returns {string} Formatted markdown comment
 */
function formatTestResults(testResultsPath, junitPath) {
  try {
    // Read test results
    const testResults = JSON.parse(fs.readFileSync(testResultsPath, 'utf8'));
    const junitContent = fs.readFileSync(junitPath, 'utf8');
    
    // Extract summary information
    const stats = testResults.stats || {};
    const { expected = 0, unexpected = 0, flaky = 0, skipped = 0 } = stats;
    const total = expected + unexpected + flaky + skipped;
    
    // Calculate duration
    const duration = testResults.stats?.duration || 0;
    const durationMinutes = Math.round(duration / 1000 / 60 * 100) / 100;
    
    // Determine overall status
    const hasFailures = unexpected > 0;
    const hasFlaky = flaky > 0;
    const status = hasFailures ? '❌ Failed' : hasFlaky ? '⚠️ Flaky' : '✅ Passed';
    
    // Build markdown comment
    let comment = `## 🎭 E2E Test Results ${status}\n\n`;
    
    // Summary table
    comment += `| Metric | Value |\n`;
    comment += `|--------|-------|\n`;
    comment += `| **Total Tests** | ${total} |\n`;
    comment += `| **✅ Passed** | ${expected} |\n`;
    comment += `| **❌ Failed** | ${unexpected} |\n`;
    comment += `| **⚠️ Flaky** | ${flaky} |\n`;
    comment += `| **⏭️ Skipped** | ${skipped} |\n`;
    comment += `| **⏱️ Duration** | ${durationMinutes}m |\n\n`;
    
    // Add failure details if any
    if (hasFailures && testResults.suites) {
      comment += `### ❌ Failed Tests\n\n`;
      const failedTests = extractFailedTests(testResults.suites);
      
      if (failedTests.length > 0) {
        failedTests.forEach(test => {
          comment += `#### 🔴 ${test.title}\n`;
          comment += `**File:** \`${test.file}\`\n`;
          comment += `**Project:** ${test.project}\n`;
          if (test.error) {
            comment += `**Error:**\n\`\`\`\n${test.error}\n\`\`\`\n\n`;
          }
        });
      }
    }
    
    // Add flaky test details if any
    if (hasFlaky && testResults.suites) {
      comment += `### ⚠️ Flaky Tests\n\n`;
      const flakyTests = extractFlakyTests(testResults.suites);
      
      if (flakyTests.length > 0) {
        flakyTests.forEach(test => {
          comment += `#### 🟡 ${test.title}\n`;
          comment += `**File:** \`${test.file}\`\n`;
          comment += `**Project:** ${test.project}\n`;
          comment += `**Attempts:** ${test.attempts}\n\n`;
        });
      }
    }
    
    // Add artifacts information
    comment += `### 📎 Test Artifacts\n\n`;
    comment += `- 📊 [HTML Report](../../actions/runs/GITHUB_RUN_ID/artifacts) - Interactive test report with detailed results\n`;
    comment += `- 📋 [JUnit Report](../../actions/runs/GITHUB_RUN_ID/artifacts) - XML format for CI/CD integration\n`;
    comment += `- 📸 Screenshots and videos - Available in artifacts for failed tests\n`;
    comment += `- 🔍 [Trace Files](../../actions/runs/GITHUB_RUN_ID/artifacts) - Detailed execution traces for debugging\n\n`;
    
    // Add footer
    comment += `---\n`;
    comment += `*Generated by GitHub Actions • [View Workflow Run](../../actions/runs/GITHUB_RUN_ID)*`;
    
    return comment;
    
  } catch (error) {
    console.error('Error formatting test results:', error);
    return `## 🎭 E2E Test Results ❌ Error\n\nFailed to parse test results: ${error.message}`;
  }
}

/**
 * Extracts failed tests from test suites
 */
function extractFailedTests(suites) {
  const failedTests = [];
  
  function traverseSuites(suites, parentFile = '') {
    suites.forEach(suite => {
      const file = suite.file || parentFile;
      
      if (suite.specs) {
        suite.specs.forEach(spec => {
          spec.tests?.forEach(test => {
            if (test.results?.some(result => result.status === 'failed')) {
              const failedResult = test.results.find(result => result.status === 'failed');
              failedTests.push({
                title: test.title,
                file: file,
                project: test.projectName || 'unknown',
                error: failedResult?.error?.message || 'No error message available'
              });
            }
          });
        });
      }
      
      if (suite.suites) {
        traverseSuites(suite.suites, file);
      }
    });
  }
  
  traverseSuites(suites);
  return failedTests;
}

/**
 * Extracts flaky tests from test suites
 */
function extractFlakyTests(suites) {
  const flakyTests = [];
  
  function traverseSuites(suites, parentFile = '') {
    suites.forEach(suite => {
      const file = suite.file || parentFile;
      
      if (suite.specs) {
        suite.specs.forEach(spec => {
          spec.tests?.forEach(test => {
            const results = test.results || [];
            const hasFailure = results.some(result => result.status === 'failed');
            const hasSuccess = results.some(result => result.status === 'passed');
            
            if (hasFailure && hasSuccess) {
              flakyTests.push({
                title: test.title,
                file: file,
                project: test.projectName || 'unknown',
                attempts: results.length
              });
            }
          });
        });
      }
      
      if (suite.suites) {
        traverseSuites(suite.suites, file);
      }
    });
  }
  
  traverseSuites(suites);
  return flakyTests;
}

// CLI usage
if (require.main === module) {
  const testResultsPath = process.argv[2];
  const junitPath = process.argv[3];
  
  if (!testResultsPath || !junitPath) {
    console.error('Usage: node format-test-results.js <test-results.json> <junit-report.xml>');
    process.exit(1);
  }
  
  if (!fs.existsSync(testResultsPath)) {
    console.error(`Test results file not found: ${testResultsPath}`);
    process.exit(1);
  }
  
  if (!fs.existsSync(junitPath)) {
    console.error(`JUnit report file not found: ${junitPath}`);
    process.exit(1);
  }
  
  const comment = formatTestResults(testResultsPath, junitPath);
  console.log(comment);
}

module.exports = { formatTestResults };