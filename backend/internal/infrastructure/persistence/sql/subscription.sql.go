// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscription.sql

package sql

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createSubscription = `-- name: CreateSubscription :exec
INSERT INTO public.subscriptions (id,
                                  friendly_name,
                                  free_trial_start_date,
                                  free_trial_end_date,
                                  provider_id,
                                  plan_id,
                                  price_id,
                                  custom_price_currency,
                                  custom_price_amount,
                                  owner_type,
                                  owner_family_id,
                                  owner_user_id,
                                  payer_type,
                                  family_id,
                                  payer_member_id,
                                  start_date,
                                  end_date,
                                  recurrency,
                                  custom_recurrency,
                                  created_at,
                                  updated_at,
                                  etag)
VALUES ($1, $2, $3, $4, $5, $6,
        $7, $8, $9, $10, $11,
        $12, $13, $14, $15, $16, $17,
        $18, $19, $20, $21, $22)
`

type CreateSubscriptionParams struct {
	ID                  uuid.UUID
	FriendlyName        *string
	FreeTrialStartDate  *time.Time
	FreeTrialEndDate    *time.Time
	ProviderID          uuid.UUID
	PlanID              *uuid.UUID
	PriceID             *uuid.UUID
	CustomPriceCurrency *string
	CustomPriceAmount   *float64
	OwnerType           string
	OwnerFamilyID       *uuid.UUID
	OwnerUserID         *string
	PayerType           *string
	FamilyID            *uuid.UUID
	PayerMemberID       *uuid.UUID
	StartDate           time.Time
	EndDate             *time.Time
	Recurrency          string
	CustomRecurrency    *int32
	CreatedAt           time.Time
	UpdatedAt           time.Time
	Etag                string
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) error {
	_, err := q.db.Exec(ctx, createSubscription,
		arg.ID,
		arg.FriendlyName,
		arg.FreeTrialStartDate,
		arg.FreeTrialEndDate,
		arg.ProviderID,
		arg.PlanID,
		arg.PriceID,
		arg.CustomPriceCurrency,
		arg.CustomPriceAmount,
		arg.OwnerType,
		arg.OwnerFamilyID,
		arg.OwnerUserID,
		arg.PayerType,
		arg.FamilyID,
		arg.PayerMemberID,
		arg.StartDate,
		arg.EndDate,
		arg.Recurrency,
		arg.CustomRecurrency,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

const createSubscriptionServiceUser = `-- name: CreateSubscriptionServiceUser :exec
INSERT INTO public.subscription_service_users (subscription_id, family_member_id)
VALUES ($1, $2)
`

type CreateSubscriptionServiceUserParams struct {
	SubscriptionID uuid.UUID
	FamilyMemberID uuid.UUID
}

func (q *Queries) CreateSubscriptionServiceUser(ctx context.Context, arg CreateSubscriptionServiceUserParams) error {
	_, err := q.db.Exec(ctx, createSubscriptionServiceUser, arg.SubscriptionID, arg.FamilyMemberID)
	return err
}

type CreateSubscriptionServiceUsersParams struct {
	SubscriptionID uuid.UUID
	FamilyMemberID uuid.UUID
}

type CreateSubscriptionsParams struct {
	ID                  uuid.UUID
	FriendlyName        *string
	FreeTrialStartDate  *time.Time
	FreeTrialEndDate    *time.Time
	ProviderID          uuid.UUID
	PlanID              *uuid.UUID
	PriceID             *uuid.UUID
	CustomPriceCurrency *string
	CustomPriceAmount   *float64
	OwnerType           string
	OwnerFamilyID       *uuid.UUID
	OwnerUserID         *string
	PayerType           *string
	FamilyID            *uuid.UUID
	PayerMemberID       *uuid.UUID
	StartDate           time.Time
	EndDate             *time.Time
	Recurrency          string
	CustomRecurrency    *int32
	CreatedAt           time.Time
	UpdatedAt           time.Time
	Etag                string
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE
FROM public.subscriptions
WHERE id = $1
`

func (q *Queries) DeleteSubscription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSubscription, id)
	return err
}

const deleteSubscriptionServiceUser = `-- name: DeleteSubscriptionServiceUser :exec
DELETE
FROM public.subscription_service_users
WHERE subscription_id = $1
  AND family_member_id = $2
`

type DeleteSubscriptionServiceUserParams struct {
	SubscriptionID uuid.UUID
	FamilyMemberID uuid.UUID
}

func (q *Queries) DeleteSubscriptionServiceUser(ctx context.Context, arg DeleteSubscriptionServiceUserParams) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionServiceUser, arg.SubscriptionID, arg.FamilyMemberID)
	return err
}

const isSubscriptionExists = `-- name: IsSubscriptionExists :one
SELECT COUNT(*)
FROM public.subscriptions s
WHERE s.id = ANY ($1::uuid[])
`

func (q *Queries) IsSubscriptionExists(ctx context.Context, dollar_1 []uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, isSubscriptionExists, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateSubscription = `-- name: UpdateSubscription :exec
UPDATE public.subscriptions
SET friendly_name         = $2,
    free_trial_start_date = $3,
    free_trial_end_date   = $4,
    provider_id           = $5,
    plan_id               = $6,
    price_id              = $7,
    custom_price_currency = $8,
    custom_price_amount   = $9,
    owner_type            = $10,
    owner_family_id       = $11,
    owner_user_id         = $12,
    payer_type            = $13,
    family_id             = $14,
    payer_member_id       = $15,
    start_date            = $16,
    end_date              = $17,
    recurrency            = $18,
    custom_recurrency     = $19,
    updated_at            = $20,
    etag                  = $21
WHERE id = $1
`

type UpdateSubscriptionParams struct {
	ID                  uuid.UUID
	FriendlyName        *string
	FreeTrialStartDate  *time.Time
	FreeTrialEndDate    *time.Time
	ProviderID          uuid.UUID
	PlanID              *uuid.UUID
	PriceID             *uuid.UUID
	CustomPriceCurrency *string
	CustomPriceAmount   *float64
	OwnerType           string
	OwnerFamilyID       *uuid.UUID
	OwnerUserID         *string
	PayerType           *string
	FamilyID            *uuid.UUID
	PayerMemberID       *uuid.UUID
	StartDate           time.Time
	EndDate             *time.Time
	Recurrency          string
	CustomRecurrency    *int32
	UpdatedAt           time.Time
	Etag                string
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) error {
	_, err := q.db.Exec(ctx, updateSubscription,
		arg.ID,
		arg.FriendlyName,
		arg.FreeTrialStartDate,
		arg.FreeTrialEndDate,
		arg.ProviderID,
		arg.PlanID,
		arg.PriceID,
		arg.CustomPriceCurrency,
		arg.CustomPriceAmount,
		arg.OwnerType,
		arg.OwnerFamilyID,
		arg.OwnerUserID,
		arg.PayerType,
		arg.FamilyID,
		arg.PayerMemberID,
		arg.StartDate,
		arg.EndDate,
		arg.Recurrency,
		arg.CustomRecurrency,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

const getSubscriptionById = `-- name: getSubscriptionById :many
SELECT s.id                    AS "subscriptions.id",
       s.owner_type            AS "subscriptions.owner_type",
       s.owner_family_id       AS "subscriptions.owner_family_id",
       s.owner_user_id         AS "subscriptions.owner_user_id",
       s.friendly_name         AS "subscriptions.friendly_name",
       s.free_trial_start_date AS "subscriptions.free_trial_start_date",
       s.free_trial_end_date   AS "subscriptions.free_trial_end_date",
       s.provider_id           AS "subscriptions.provider_id",
       s.plan_id               AS "subscriptions.plan_id",
       s.price_id              AS "subscriptions.price_id",
       s.family_id             AS "subscriptions.family_id",
       s.payer_type            AS "subscriptions.payer_type",
       s.payer_member_id       AS "subscriptions.payer_member_id",
       s.start_date            AS "subscriptions.start_date",
       s.end_date              AS "subscriptions.end_date",
       s.recurrency            AS "subscriptions.recurrency",
       s.custom_recurrency     AS "subscriptions.custom_recurrency",
       s.custom_price_currency AS "subscriptions.custom_price_currency",
       s.custom_price_amount   AS "subscriptions.custom_price_amount",
       s.created_at            AS "subscriptions.created_at",
       s.updated_at            AS "subscriptions.updated_at",
       s.etag                  AS "subscriptions.etag",
       su.family_member_id     AS "subscription_service_users.family_member_id"
FROM public.subscriptions s
         LEFT JOIN subscription_service_users su ON su.subscription_id = s.id
WHERE s.id = $1
`

type getSubscriptionByIdRow struct {
	SubscriptionsID                        uuid.UUID
	SubscriptionsOwnerType                 string
	SubscriptionsOwnerFamilyID             *uuid.UUID
	SubscriptionsOwnerUserID               *string
	SubscriptionsFriendlyName              *string
	SubscriptionsFreeTrialStartDate        *time.Time
	SubscriptionsFreeTrialEndDate          *time.Time
	SubscriptionsProviderID                uuid.UUID
	SubscriptionsPlanID                    *uuid.UUID
	SubscriptionsPriceID                   *uuid.UUID
	SubscriptionsFamilyID                  *uuid.UUID
	SubscriptionsPayerType                 *string
	SubscriptionsPayerMemberID             *uuid.UUID
	SubscriptionsStartDate                 time.Time
	SubscriptionsEndDate                   *time.Time
	SubscriptionsRecurrency                string
	SubscriptionsCustomRecurrency          *int32
	SubscriptionsCustomPriceCurrency       *string
	SubscriptionsCustomPriceAmount         *float64
	SubscriptionsCreatedAt                 time.Time
	SubscriptionsUpdatedAt                 time.Time
	SubscriptionsEtag                      string
	SubscriptionServiceUsersFamilyMemberID *uuid.UUID
}

func (q *Queries) getSubscriptionById(ctx context.Context, id uuid.UUID) ([]getSubscriptionByIdRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getSubscriptionByIdRow
	for rows.Next() {
		var i getSubscriptionByIdRow
		if err := rows.Scan(
			&i.SubscriptionsID,
			&i.SubscriptionsOwnerType,
			&i.SubscriptionsOwnerFamilyID,
			&i.SubscriptionsOwnerUserID,
			&i.SubscriptionsFriendlyName,
			&i.SubscriptionsFreeTrialStartDate,
			&i.SubscriptionsFreeTrialEndDate,
			&i.SubscriptionsProviderID,
			&i.SubscriptionsPlanID,
			&i.SubscriptionsPriceID,
			&i.SubscriptionsFamilyID,
			&i.SubscriptionsPayerType,
			&i.SubscriptionsPayerMemberID,
			&i.SubscriptionsStartDate,
			&i.SubscriptionsEndDate,
			&i.SubscriptionsRecurrency,
			&i.SubscriptionsCustomRecurrency,
			&i.SubscriptionsCustomPriceCurrency,
			&i.SubscriptionsCustomPriceAmount,
			&i.SubscriptionsCreatedAt,
			&i.SubscriptionsUpdatedAt,
			&i.SubscriptionsEtag,
			&i.SubscriptionServiceUsersFamilyMemberID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionByIdForUser = `-- name: getSubscriptionByIdForUser :many
SELECT s.id                    AS "subscriptions.id",
       s.owner_type            AS "subscriptions.owner_type",
       s.owner_family_id       AS "subscriptions.owner_family_id",
       s.owner_user_id         AS "subscriptions.owner_user_id",
       s.friendly_name         AS "subscriptions.friendly_name",
       s.free_trial_start_date AS "subscriptions.free_trial_start_date",
       s.free_trial_end_date   AS "subscriptions.free_trial_end_date",
       s.provider_id           AS "subscriptions.provider_id",
       s.plan_id               AS "subscriptions.plan_id",
       s.price_id              AS "subscriptions.price_id",
       s.family_id             AS "subscriptions.family_id",
       s.payer_type            AS "subscriptions.payer_type",
       s.payer_member_id       AS "subscriptions.payer_member_id",
       s.start_date            AS "subscriptions.start_date",
       s.end_date              AS "subscriptions.end_date",
       s.recurrency            AS "subscriptions.recurrency",
       s.custom_recurrency     AS "subscriptions.custom_recurrency",
       s.custom_price_currency AS "subscriptions.custom_price_currency",
       s.custom_price_amount   AS "subscriptions.custom_price_amount",
       s.created_at            AS "subscriptions.created_at",
       s.updated_at            AS "subscriptions.updated_at",
       s.etag                  AS "subscriptions.etag",
       su.family_member_id     AS "subscription_service_users.family_member_id"
FROM (SELECT s.id, s.owner_type, s.owner_family_id, s.owner_user_id, s.friendly_name, s.free_trial_start_date, s.free_trial_end_date, s.provider_id, s.plan_id, s.price_id, s.family_id, s.payer_type, s.payer_member_id, s.start_date, s.end_date, s.recurrency, s.custom_recurrency, s.custom_price_currency, s.custom_price_amount, s.created_at, s.updated_at, s.etag
      FROM public.subscriptions s
               LEFT JOIN subscription_service_users su ON su.subscription_id = s.id
               LEFT JOIN families f ON f.id = s.family_id
               LEFT JOIN family_members fm ON fm.id = su.family_member_id
      WHERE (s.owner_type = 'family' AND fm.user_id = $1)
         OR (s.owner_type = 'personal' AND s.owner_user_id = $1)) s
         LEFT JOIN subscription_service_users su ON su.subscription_id = s.id
WHERE s.id = $2
`

type getSubscriptionByIdForUserParams struct {
	UserID *string
	ID     uuid.UUID
}

type getSubscriptionByIdForUserRow struct {
	SubscriptionsID                        uuid.UUID
	SubscriptionsOwnerType                 string
	SubscriptionsOwnerFamilyID             *uuid.UUID
	SubscriptionsOwnerUserID               *string
	SubscriptionsFriendlyName              *string
	SubscriptionsFreeTrialStartDate        *time.Time
	SubscriptionsFreeTrialEndDate          *time.Time
	SubscriptionsProviderID                uuid.UUID
	SubscriptionsPlanID                    *uuid.UUID
	SubscriptionsPriceID                   *uuid.UUID
	SubscriptionsFamilyID                  *uuid.UUID
	SubscriptionsPayerType                 *string
	SubscriptionsPayerMemberID             *uuid.UUID
	SubscriptionsStartDate                 time.Time
	SubscriptionsEndDate                   *time.Time
	SubscriptionsRecurrency                string
	SubscriptionsCustomRecurrency          *int32
	SubscriptionsCustomPriceCurrency       *string
	SubscriptionsCustomPriceAmount         *float64
	SubscriptionsCreatedAt                 time.Time
	SubscriptionsUpdatedAt                 time.Time
	SubscriptionsEtag                      string
	SubscriptionServiceUsersFamilyMemberID *uuid.UUID
}

func (q *Queries) getSubscriptionByIdForUser(ctx context.Context, arg getSubscriptionByIdForUserParams) ([]getSubscriptionByIdForUserRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionByIdForUser, arg.UserID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getSubscriptionByIdForUserRow
	for rows.Next() {
		var i getSubscriptionByIdForUserRow
		if err := rows.Scan(
			&i.SubscriptionsID,
			&i.SubscriptionsOwnerType,
			&i.SubscriptionsOwnerFamilyID,
			&i.SubscriptionsOwnerUserID,
			&i.SubscriptionsFriendlyName,
			&i.SubscriptionsFreeTrialStartDate,
			&i.SubscriptionsFreeTrialEndDate,
			&i.SubscriptionsProviderID,
			&i.SubscriptionsPlanID,
			&i.SubscriptionsPriceID,
			&i.SubscriptionsFamilyID,
			&i.SubscriptionsPayerType,
			&i.SubscriptionsPayerMemberID,
			&i.SubscriptionsStartDate,
			&i.SubscriptionsEndDate,
			&i.SubscriptionsRecurrency,
			&i.SubscriptionsCustomRecurrency,
			&i.SubscriptionsCustomPriceCurrency,
			&i.SubscriptionsCustomPriceAmount,
			&i.SubscriptionsCreatedAt,
			&i.SubscriptionsUpdatedAt,
			&i.SubscriptionsEtag,
			&i.SubscriptionServiceUsersFamilyMemberID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptions = `-- name: getSubscriptions :many
SELECT s.id                    AS "subscriptions.id",
       s.owner_type            AS "subscriptions.owner_type",
       s.owner_family_id       AS "subscriptions.owner_family_id",
       s.owner_user_id         AS "subscriptions.owner_user_id",
       s.friendly_name         AS "subscriptions.friendly_name",
       s.free_trial_start_date AS "subscriptions.free_trial_start_date",
       s.free_trial_end_date   AS "subscriptions.free_trial_end_date",
       s.provider_id           AS "subscriptions.provider_id",
       s.plan_id               AS "subscriptions.plan_id",
       s.price_id              AS "subscriptions.price_id",
       s.family_id             AS "subscriptions.family_id",
       s.payer_type            AS "subscriptions.payer_type",
       s.payer_member_id       AS "subscriptions.payer_member_id",
       s.start_date            AS "subscriptions.start_date",
       s.end_date              AS "subscriptions.end_date",
       s.recurrency            AS "subscriptions.recurrency",
       s.custom_recurrency     AS "subscriptions.custom_recurrency",
       s.custom_price_currency AS "subscriptions.custom_price_currency",
       s.custom_price_amount   AS "subscriptions.custom_price_amount",
       s.created_at            AS "subscriptions.created_at",
       s.updated_at            AS "subscriptions.updated_at",
       s.etag                  AS "subscriptions.etag",
       su.family_member_id     AS "subscription_service_users.family_member_id",
       s.total_count           AS "total_count"
FROM (SELECT s.id, s.owner_type, s.owner_family_id, s.owner_user_id, s.friendly_name, s.free_trial_start_date, s.free_trial_end_date, s.provider_id, s.plan_id, s.price_id, s.family_id, s.payer_type, s.payer_member_id, s.start_date, s.end_date, s.recurrency, s.custom_recurrency, s.custom_price_currency, s.custom_price_amount, s.created_at, s.updated_at, s.etag,
             COUNT(*) OVER () AS total_count
      FROM public.subscriptions s
      ORDER BY s.Id
      LIMIT $1 OFFSET $2) s
         LEFT JOIN subscription_service_users su ON su.subscription_id = s.id
`

type getSubscriptionsParams struct {
	Limit  int32
	Offset int32
}

type getSubscriptionsRow struct {
	SubscriptionsID                        uuid.UUID
	SubscriptionsOwnerType                 string
	SubscriptionsOwnerFamilyID             *uuid.UUID
	SubscriptionsOwnerUserID               *string
	SubscriptionsFriendlyName              *string
	SubscriptionsFreeTrialStartDate        *time.Time
	SubscriptionsFreeTrialEndDate          *time.Time
	SubscriptionsProviderID                uuid.UUID
	SubscriptionsPlanID                    *uuid.UUID
	SubscriptionsPriceID                   *uuid.UUID
	SubscriptionsFamilyID                  *uuid.UUID
	SubscriptionsPayerType                 *string
	SubscriptionsPayerMemberID             *uuid.UUID
	SubscriptionsStartDate                 time.Time
	SubscriptionsEndDate                   *time.Time
	SubscriptionsRecurrency                string
	SubscriptionsCustomRecurrency          *int32
	SubscriptionsCustomPriceCurrency       *string
	SubscriptionsCustomPriceAmount         *float64
	SubscriptionsCreatedAt                 time.Time
	SubscriptionsUpdatedAt                 time.Time
	SubscriptionsEtag                      string
	SubscriptionServiceUsersFamilyMemberID *uuid.UUID
	TotalCount                             int64
}

func (q *Queries) getSubscriptions(ctx context.Context, arg getSubscriptionsParams) ([]getSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getSubscriptionsRow
	for rows.Next() {
		var i getSubscriptionsRow
		if err := rows.Scan(
			&i.SubscriptionsID,
			&i.SubscriptionsOwnerType,
			&i.SubscriptionsOwnerFamilyID,
			&i.SubscriptionsOwnerUserID,
			&i.SubscriptionsFriendlyName,
			&i.SubscriptionsFreeTrialStartDate,
			&i.SubscriptionsFreeTrialEndDate,
			&i.SubscriptionsProviderID,
			&i.SubscriptionsPlanID,
			&i.SubscriptionsPriceID,
			&i.SubscriptionsFamilyID,
			&i.SubscriptionsPayerType,
			&i.SubscriptionsPayerMemberID,
			&i.SubscriptionsStartDate,
			&i.SubscriptionsEndDate,
			&i.SubscriptionsRecurrency,
			&i.SubscriptionsCustomRecurrency,
			&i.SubscriptionsCustomPriceCurrency,
			&i.SubscriptionsCustomPriceAmount,
			&i.SubscriptionsCreatedAt,
			&i.SubscriptionsUpdatedAt,
			&i.SubscriptionsEtag,
			&i.SubscriptionServiceUsersFamilyMemberID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsForUser = `-- name: getSubscriptionsForUser :many
SELECT s.id                    AS "subscriptions.id",
       s.owner_type            AS "subscriptions.owner_type",
       s.owner_family_id       AS "subscriptions.owner_family_id",
       s.owner_user_id         AS "subscriptions.owner_user_id",
       s.friendly_name         AS "subscriptions.friendly_name",
       s.free_trial_start_date AS "subscriptions.free_trial_start_date",
       s.free_trial_end_date   AS "subscriptions.free_trial_end_date",
       s.provider_id           AS "subscriptions.provider_id",
       s.plan_id               AS "subscriptions.plan_id",
       s.price_id              AS "subscriptions.price_id",
       s.family_id             AS "subscriptions.family_id",
       s.payer_type            AS "subscriptions.payer_type",
       s.payer_member_id       AS "subscriptions.payer_member_id",
       s.start_date            AS "subscriptions.start_date",
       s.end_date              AS "subscriptions.end_date",
       s.recurrency            AS "subscriptions.recurrency",
       s.custom_recurrency     AS "subscriptions.custom_recurrency",
       s.custom_price_currency AS "subscriptions.custom_price_currency",
       s.custom_price_amount   AS "subscriptions.custom_price_amount",
       s.created_at            AS "subscriptions.created_at",
       s.updated_at            AS "subscriptions.updated_at",
       s.etag                  AS "subscriptions.etag",
       su.family_member_id     AS "subscription_service_users.family_member_id",
       s.total_count           AS "total_count"
FROM (SELECT s.id, s.owner_type, s.owner_family_id, s.owner_user_id, s.friendly_name, s.free_trial_start_date, s.free_trial_end_date, s.provider_id, s.plan_id, s.price_id, s.family_id, s.payer_type, s.payer_member_id, s.start_date, s.end_date, s.recurrency, s.custom_recurrency, s.custom_price_currency, s.custom_price_amount, s.created_at, s.updated_at, s.etag,
             COUNT(*) OVER () AS total_count
      FROM public.subscriptions s
               LEFT JOIN subscription_service_users su ON su.subscription_id = s.id
               LEFT JOIN families f ON f.id = s.family_id
               LEFT JOIN family_members fm ON fm.id = su.family_member_id
               LEFT JOIN public.labels l ON l.id = s.plan_id
               LEFT JOIN public.providers p ON p.id = s.provider_id
      WHERE (s.owner_type = 'family' AND fm.user_id = $1)
         OR (s.owner_type = 'personal' AND s.owner_user_id = $1)
      ORDER BY s.Id
      LIMIT $2 OFFSET $3) s
         LEFT JOIN subscription_service_users su ON su.subscription_id = s.id
`

type getSubscriptionsForUserParams struct {
	UserID *string
	Limit  int32
	Offset int32
}

type getSubscriptionsForUserRow struct {
	SubscriptionsID                        uuid.UUID
	SubscriptionsOwnerType                 string
	SubscriptionsOwnerFamilyID             *uuid.UUID
	SubscriptionsOwnerUserID               *string
	SubscriptionsFriendlyName              *string
	SubscriptionsFreeTrialStartDate        *time.Time
	SubscriptionsFreeTrialEndDate          *time.Time
	SubscriptionsProviderID                uuid.UUID
	SubscriptionsPlanID                    *uuid.UUID
	SubscriptionsPriceID                   *uuid.UUID
	SubscriptionsFamilyID                  *uuid.UUID
	SubscriptionsPayerType                 *string
	SubscriptionsPayerMemberID             *uuid.UUID
	SubscriptionsStartDate                 time.Time
	SubscriptionsEndDate                   *time.Time
	SubscriptionsRecurrency                string
	SubscriptionsCustomRecurrency          *int32
	SubscriptionsCustomPriceCurrency       *string
	SubscriptionsCustomPriceAmount         *float64
	SubscriptionsCreatedAt                 time.Time
	SubscriptionsUpdatedAt                 time.Time
	SubscriptionsEtag                      string
	SubscriptionServiceUsersFamilyMemberID *uuid.UUID
	TotalCount                             int64
}

func (q *Queries) getSubscriptionsForUser(ctx context.Context, arg getSubscriptionsForUserParams) ([]getSubscriptionsForUserRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getSubscriptionsForUserRow
	for rows.Next() {
		var i getSubscriptionsForUserRow
		if err := rows.Scan(
			&i.SubscriptionsID,
			&i.SubscriptionsOwnerType,
			&i.SubscriptionsOwnerFamilyID,
			&i.SubscriptionsOwnerUserID,
			&i.SubscriptionsFriendlyName,
			&i.SubscriptionsFreeTrialStartDate,
			&i.SubscriptionsFreeTrialEndDate,
			&i.SubscriptionsProviderID,
			&i.SubscriptionsPlanID,
			&i.SubscriptionsPriceID,
			&i.SubscriptionsFamilyID,
			&i.SubscriptionsPayerType,
			&i.SubscriptionsPayerMemberID,
			&i.SubscriptionsStartDate,
			&i.SubscriptionsEndDate,
			&i.SubscriptionsRecurrency,
			&i.SubscriptionsCustomRecurrency,
			&i.SubscriptionsCustomPriceCurrency,
			&i.SubscriptionsCustomPriceAmount,
			&i.SubscriptionsCreatedAt,
			&i.SubscriptionsUpdatedAt,
			&i.SubscriptionsEtag,
			&i.SubscriptionServiceUsersFamilyMemberID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsForUserWithSearch = `-- name: getSubscriptionsForUserWithSearch :many
SELECT s.id                    AS "subscriptions.id",
       s.owner_type            AS "subscriptions.owner_type",
       s.owner_family_id       AS "subscriptions.owner_family_id",
       s.owner_user_id         AS "subscriptions.owner_user_id",
       s.friendly_name         AS "subscriptions.friendly_name",
       s.free_trial_start_date AS "subscriptions.free_trial_start_date",
       s.free_trial_end_date   AS "subscriptions.free_trial_end_date",
       s.provider_id           AS "subscriptions.provider_id",
       s.plan_id               AS "subscriptions.plan_id",
       s.price_id              AS "subscriptions.price_id",
       s.family_id             AS "subscriptions.family_id",
       s.payer_type            AS "subscriptions.payer_type",
       s.payer_member_id       AS "subscriptions.payer_member_id",
       s.start_date            AS "subscriptions.start_date",
       s.end_date              AS "subscriptions.end_date",
       s.recurrency            AS "subscriptions.recurrency",
       s.custom_recurrency     AS "subscriptions.custom_recurrency",
       s.custom_price_currency AS "subscriptions.custom_price_currency",
       s.custom_price_amount   AS "subscriptions.custom_price_amount",
       s.created_at            AS "subscriptions.created_at",
       s.updated_at            AS "subscriptions.updated_at",
       s.etag                  AS "subscriptions.etag",
       su.family_member_id     AS "subscription_service_users.family_member_id",
       s.total_count           AS "total_count"
FROM (SELECT s.id, s.owner_type, s.owner_family_id, s.owner_user_id, s.friendly_name, s.free_trial_start_date, s.free_trial_end_date, s.provider_id, s.plan_id, s.price_id, s.family_id, s.payer_type, s.payer_member_id, s.start_date, s.end_date, s.recurrency, s.custom_recurrency, s.custom_price_currency, s.custom_price_amount, s.created_at, s.updated_at, s.etag,
             COUNT(*) OVER () AS total_count
      FROM public.subscriptions s
               LEFT JOIN subscription_service_users su ON su.subscription_id = s.id
               LEFT JOIN families f ON f.id = s.family_id
               LEFT JOIN family_members fm ON fm.id = su.family_member_id
               LEFT JOIN public.labels l ON l.id = s.plan_id
               LEFT JOIN public.providers p ON p.id = s.provider_id
      WHERE ((s.owner_type = 'family' AND fm.user_id = $1)
          OR (s.owner_type = 'personal' AND s.owner_user_id = $1))
        AND (s.friendly_name ILIKE $2 OR
             l.name ILIKE $2 OR
             p.name ILIKE $2)
      ORDER BY s.Id
      LIMIT $3 OFFSET $4) s
         LEFT JOIN subscription_service_users su ON su.subscription_id = s.id
`

type getSubscriptionsForUserWithSearchParams struct {
	UserID       *string
	FriendlyName *string
	Limit        int32
	Offset       int32
}

type getSubscriptionsForUserWithSearchRow struct {
	SubscriptionsID                        uuid.UUID
	SubscriptionsOwnerType                 string
	SubscriptionsOwnerFamilyID             *uuid.UUID
	SubscriptionsOwnerUserID               *string
	SubscriptionsFriendlyName              *string
	SubscriptionsFreeTrialStartDate        *time.Time
	SubscriptionsFreeTrialEndDate          *time.Time
	SubscriptionsProviderID                uuid.UUID
	SubscriptionsPlanID                    *uuid.UUID
	SubscriptionsPriceID                   *uuid.UUID
	SubscriptionsFamilyID                  *uuid.UUID
	SubscriptionsPayerType                 *string
	SubscriptionsPayerMemberID             *uuid.UUID
	SubscriptionsStartDate                 time.Time
	SubscriptionsEndDate                   *time.Time
	SubscriptionsRecurrency                string
	SubscriptionsCustomRecurrency          *int32
	SubscriptionsCustomPriceCurrency       *string
	SubscriptionsCustomPriceAmount         *float64
	SubscriptionsCreatedAt                 time.Time
	SubscriptionsUpdatedAt                 time.Time
	SubscriptionsEtag                      string
	SubscriptionServiceUsersFamilyMemberID *uuid.UUID
	TotalCount                             int64
}

func (q *Queries) getSubscriptionsForUserWithSearch(ctx context.Context, arg getSubscriptionsForUserWithSearchParams) ([]getSubscriptionsForUserWithSearchRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsForUserWithSearch,
		arg.UserID,
		arg.FriendlyName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getSubscriptionsForUserWithSearchRow
	for rows.Next() {
		var i getSubscriptionsForUserWithSearchRow
		if err := rows.Scan(
			&i.SubscriptionsID,
			&i.SubscriptionsOwnerType,
			&i.SubscriptionsOwnerFamilyID,
			&i.SubscriptionsOwnerUserID,
			&i.SubscriptionsFriendlyName,
			&i.SubscriptionsFreeTrialStartDate,
			&i.SubscriptionsFreeTrialEndDate,
			&i.SubscriptionsProviderID,
			&i.SubscriptionsPlanID,
			&i.SubscriptionsPriceID,
			&i.SubscriptionsFamilyID,
			&i.SubscriptionsPayerType,
			&i.SubscriptionsPayerMemberID,
			&i.SubscriptionsStartDate,
			&i.SubscriptionsEndDate,
			&i.SubscriptionsRecurrency,
			&i.SubscriptionsCustomRecurrency,
			&i.SubscriptionsCustomPriceCurrency,
			&i.SubscriptionsCustomPriceAmount,
			&i.SubscriptionsCreatedAt,
			&i.SubscriptionsUpdatedAt,
			&i.SubscriptionsEtag,
			&i.SubscriptionServiceUsersFamilyMemberID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
