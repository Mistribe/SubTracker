// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: currency_rate.sql

package sql

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createCurrencyRate = `-- name: CreateCurrencyRate :exec
INSERT INTO public.currency_rates (id, from_currency, to_currency, rate_date, exchange_rate,
                                   created_at, updated_at, etag)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateCurrencyRateParams struct {
	ID           uuid.UUID
	FromCurrency string
	ToCurrency   string
	RateDate     time.Time
	ExchangeRate float64
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Etag         string
}

func (q *Queries) CreateCurrencyRate(ctx context.Context, arg CreateCurrencyRateParams) error {
	_, err := q.db.Exec(ctx, createCurrencyRate,
		arg.ID,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.RateDate,
		arg.ExchangeRate,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

type CreateCurrencyRatesParams struct {
	ID           uuid.UUID
	FromCurrency string
	ToCurrency   string
	RateDate     time.Time
	ExchangeRate float64
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Etag         string
}

const deleteCurrencyRate = `-- name: DeleteCurrencyRate :exec
DELETE
FROM public.currency_rates
WHERE id = $1
`

func (q *Queries) DeleteCurrencyRate(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCurrencyRate, id)
	return err
}

const getCurrencyRateById = `-- name: GetCurrencyRateById :one
SELECT cr.id, cr.from_currency, cr.to_currency, cr.rate_date, cr.exchange_rate, cr.created_at, cr.updated_at, cr.etag
FROM public.currency_rates cr
WHERE cr.id = $1
`

type GetCurrencyRateByIdRow struct {
	CurrencyRate CurrencyRate
}

func (q *Queries) GetCurrencyRateById(ctx context.Context, id uuid.UUID) (GetCurrencyRateByIdRow, error) {
	row := q.db.QueryRow(ctx, getCurrencyRateById, id)
	var i GetCurrencyRateByIdRow
	err := row.Scan(
		&i.CurrencyRate.ID,
		&i.CurrencyRate.FromCurrency,
		&i.CurrencyRate.ToCurrency,
		&i.CurrencyRate.RateDate,
		&i.CurrencyRate.ExchangeRate,
		&i.CurrencyRate.CreatedAt,
		&i.CurrencyRate.UpdatedAt,
		&i.CurrencyRate.Etag,
	)
	return i, err
}

const getCurrencyRatesByDate = `-- name: GetCurrencyRatesByDate :many
SELECT cr.id, cr.from_currency, cr.to_currency, cr.rate_date, cr.exchange_rate, cr.created_at, cr.updated_at, cr.etag
FROM public.currency_rates cr
WHERE cr.rate_date = $1
ORDER BY cr.from_currency, cr.to_currency
`

type GetCurrencyRatesByDateRow struct {
	CurrencyRate CurrencyRate
}

func (q *Queries) GetCurrencyRatesByDate(ctx context.Context, rateDate time.Time) ([]GetCurrencyRatesByDateRow, error) {
	rows, err := q.db.Query(ctx, getCurrencyRatesByDate, rateDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrencyRatesByDateRow
	for rows.Next() {
		var i GetCurrencyRatesByDateRow
		if err := rows.Scan(
			&i.CurrencyRate.ID,
			&i.CurrencyRate.FromCurrency,
			&i.CurrencyRate.ToCurrency,
			&i.CurrencyRate.RateDate,
			&i.CurrencyRate.ExchangeRate,
			&i.CurrencyRate.CreatedAt,
			&i.CurrencyRate.UpdatedAt,
			&i.CurrencyRate.Etag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestUpdateDate = `-- name: GetLatestUpdateDate :one
SELECT MAX(cr.updated_at)::timestamp AS latest_update_date
FROM public.currency_rates cr
`

func (q *Queries) GetLatestUpdateDate(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRow(ctx, getLatestUpdateDate)
	var latest_update_date time.Time
	err := row.Scan(&latest_update_date)
	return latest_update_date, err
}

const isCurrencyRateExists = `-- name: IsCurrencyRateExists :one
SELECT COUNT(*)
FROM public.currency_rates
WHERE id = ANY ($1::uuid[])
`

func (q *Queries) IsCurrencyRateExists(ctx context.Context, dollar_1 []uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, isCurrencyRateExists, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateCurrencyRate = `-- name: UpdateCurrencyRate :exec
UPDATE public.currency_rates
SET from_currency = $2,
    to_currency   = $3,
    rate_date     = $4,
    exchange_rate = $5,
    updated_at    = $6,
    etag          = $7
WHERE id = $1
`

type UpdateCurrencyRateParams struct {
	ID           uuid.UUID
	FromCurrency string
	ToCurrency   string
	RateDate     time.Time
	ExchangeRate float64
	UpdatedAt    time.Time
	Etag         string
}

func (q *Queries) UpdateCurrencyRate(ctx context.Context, arg UpdateCurrencyRateParams) error {
	_, err := q.db.Exec(ctx, updateCurrencyRate,
		arg.ID,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.RateDate,
		arg.ExchangeRate,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}
