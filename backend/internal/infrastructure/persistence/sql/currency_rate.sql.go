// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: currency_rate.sql

package sql

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createCurrencyRate = `-- name: CreateCurrencyRate :exec
INSERT INTO public.currency_rates (
    id, from_currency, to_currency, rate_date, exchange_rate, 
    created_at, updated_at, etag
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
`

type CreateCurrencyRateParams struct {
	ID           uuid.UUID
	FromCurrency string
	ToCurrency   string
	RateDate     time.Time
	ExchangeRate float64
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Etag         string
}

func (q *Queries) CreateCurrencyRate(ctx context.Context, arg CreateCurrencyRateParams) error {
	_, err := q.db.Exec(ctx, createCurrencyRate,
		arg.ID,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.RateDate,
		arg.ExchangeRate,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

type CreateCurrencyRatesParams struct {
	ID           uuid.UUID
	FromCurrency string
	ToCurrency   string
	RateDate     time.Time
	ExchangeRate float64
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Etag         string
}

const deleteCurrencyRate = `-- name: DeleteCurrencyRate :exec
DELETE FROM public.currency_rates
WHERE id = $1
`

func (q *Queries) DeleteCurrencyRate(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCurrencyRate, id)
	return err
}

const getCurrencyRateByDate = `-- name: GetCurrencyRateByDate :one
SELECT id, from_currency, to_currency, rate_date, exchange_rate, created_at, updated_at, etag FROM public.currency_rates
WHERE from_currency = $1 AND to_currency = $2
  AND rate_date <= $3
ORDER BY rate_date DESC
LIMIT 1
`

type GetCurrencyRateByDateParams struct {
	FromCurrency string
	ToCurrency   string
	RateDate     time.Time
}

func (q *Queries) GetCurrencyRateByDate(ctx context.Context, arg GetCurrencyRateByDateParams) (CurrencyRate, error) {
	row := q.db.QueryRow(ctx, getCurrencyRateByDate, arg.FromCurrency, arg.ToCurrency, arg.RateDate)
	var i CurrencyRate
	err := row.Scan(
		&i.ID,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.RateDate,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Etag,
	)
	return i, err
}

const getCurrencyRateById = `-- name: GetCurrencyRateById :one
SELECT id, from_currency, to_currency, rate_date, exchange_rate, created_at, updated_at, etag FROM public.currency_rates
WHERE id = $1
`

func (q *Queries) GetCurrencyRateById(ctx context.Context, id uuid.UUID) (CurrencyRate, error) {
	row := q.db.QueryRow(ctx, getCurrencyRateById, id)
	var i CurrencyRate
	err := row.Scan(
		&i.ID,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.RateDate,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Etag,
	)
	return i, err
}

const getCurrencyRates = `-- name: GetCurrencyRates :many
SELECT id, from_currency, to_currency, rate_date, exchange_rate, created_at, updated_at, etag FROM public.currency_rates
ORDER BY from_currency, to_currency, rate_date DESC
LIMIT $1 OFFSET $2
`

type GetCurrencyRatesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetCurrencyRates(ctx context.Context, arg GetCurrencyRatesParams) ([]CurrencyRate, error) {
	rows, err := q.db.Query(ctx, getCurrencyRates, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CurrencyRate
	for rows.Next() {
		var i CurrencyRate
		if err := rows.Scan(
			&i.ID,
			&i.FromCurrency,
			&i.ToCurrency,
			&i.RateDate,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Etag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrencyRatesCount = `-- name: GetCurrencyRatesCount :one
SELECT COUNT(*) FROM public.currency_rates
`

func (q *Queries) GetCurrencyRatesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCurrencyRatesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestCurrencyRate = `-- name: GetLatestCurrencyRate :one
SELECT id, from_currency, to_currency, rate_date, exchange_rate, created_at, updated_at, etag FROM public.currency_rates
WHERE from_currency = $1 AND to_currency = $2
ORDER BY rate_date DESC
LIMIT 1
`

type GetLatestCurrencyRateParams struct {
	FromCurrency string
	ToCurrency   string
}

func (q *Queries) GetLatestCurrencyRate(ctx context.Context, arg GetLatestCurrencyRateParams) (CurrencyRate, error) {
	row := q.db.QueryRow(ctx, getLatestCurrencyRate, arg.FromCurrency, arg.ToCurrency)
	var i CurrencyRate
	err := row.Scan(
		&i.ID,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.RateDate,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Etag,
	)
	return i, err
}

const isCurrencyRateExists = `-- name: IsCurrencyRateExists :one
SELECT COUNT(*) FROM public.currency_rates
WHERE id = ANY($1::uuid[])
`

func (q *Queries) IsCurrencyRateExists(ctx context.Context, dollar_1 []uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, isCurrencyRateExists, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateCurrencyRate = `-- name: UpdateCurrencyRate :exec
UPDATE public.currency_rates
SET from_currency = $2,
    to_currency = $3,
    rate_date = $4,
    exchange_rate = $5,
    updated_at = $6,
    etag = $7
WHERE id = $1
`

type UpdateCurrencyRateParams struct {
	ID           uuid.UUID
	FromCurrency string
	ToCurrency   string
	RateDate     time.Time
	ExchangeRate float64
	UpdatedAt    time.Time
	Etag         string
}

func (q *Queries) UpdateCurrencyRate(ctx context.Context, arg UpdateCurrencyRateParams) error {
	_, err := q.db.Exec(ctx, updateCurrencyRate,
		arg.ID,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.RateDate,
		arg.ExchangeRate,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}
