// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package sql

import (
	"context"
)

// iteratorForCreateCurrencyRates implements pgx.CopyFromSource.
type iteratorForCreateCurrencyRates struct {
	rows                 []CreateCurrencyRatesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateCurrencyRates) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateCurrencyRates) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].FromCurrency,
		r.rows[0].ToCurrency,
		r.rows[0].RateDate,
		r.rows[0].ExchangeRate,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].Etag,
	}, nil
}

func (r iteratorForCreateCurrencyRates) Err() error {
	return nil
}

func (q *Queries) CreateCurrencyRates(ctx context.Context, arg []CreateCurrencyRatesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "currency_rates"}, []string{"id", "from_currency", "to_currency", "rate_date", "exchange_rate", "created_at", "updated_at", "etag"}, &iteratorForCreateCurrencyRates{rows: arg})
}

// iteratorForCreateFamilies implements pgx.CopyFromSource.
type iteratorForCreateFamilies struct {
	rows                 []CreateFamiliesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateFamilies) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateFamilies) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Name,
		r.rows[0].OwnerID,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].Etag,
	}, nil
}

func (r iteratorForCreateFamilies) Err() error {
	return nil
}

func (q *Queries) CreateFamilies(ctx context.Context, arg []CreateFamiliesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "families"}, []string{"id", "name", "owner_id", "created_at", "updated_at", "etag"}, &iteratorForCreateFamilies{rows: arg})
}

// iteratorForCreateFamilyMembers implements pgx.CopyFromSource.
type iteratorForCreateFamilyMembers struct {
	rows                 []CreateFamilyMembersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateFamilyMembers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateFamilyMembers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].FamilyID,
		r.rows[0].UserID,
		r.rows[0].Name,
		r.rows[0].Type,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].Etag,
	}, nil
}

func (r iteratorForCreateFamilyMembers) Err() error {
	return nil
}

func (q *Queries) CreateFamilyMembers(ctx context.Context, arg []CreateFamilyMembersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "family_members"}, []string{"id", "family_id", "user_id", "name", "type", "created_at", "updated_at", "etag"}, &iteratorForCreateFamilyMembers{rows: arg})
}

// iteratorForCreateLabels implements pgx.CopyFromSource.
type iteratorForCreateLabels struct {
	rows                 []CreateLabelsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateLabels) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateLabels) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].OwnerType,
		r.rows[0].OwnerFamilyID,
		r.rows[0].OwnerUserID,
		r.rows[0].Name,
		r.rows[0].Key,
		r.rows[0].Color,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].Etag,
	}, nil
}

func (r iteratorForCreateLabels) Err() error {
	return nil
}

func (q *Queries) CreateLabels(ctx context.Context, arg []CreateLabelsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "labels"}, []string{"id", "owner_type", "owner_family_id", "owner_user_id", "name", "key", "color", "created_at", "updated_at", "etag"}, &iteratorForCreateLabels{rows: arg})
}

// iteratorForCreateProviderLabels implements pgx.CopyFromSource.
type iteratorForCreateProviderLabels struct {
	rows                 []CreateProviderLabelsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateProviderLabels) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateProviderLabels) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].LabelID,
		r.rows[0].ProviderID,
	}, nil
}

func (r iteratorForCreateProviderLabels) Err() error {
	return nil
}

func (q *Queries) CreateProviderLabels(ctx context.Context, arg []CreateProviderLabelsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "provider_labels"}, []string{"label_id", "provider_id"}, &iteratorForCreateProviderLabels{rows: arg})
}

// iteratorForCreateProviderPlans implements pgx.CopyFromSource.
type iteratorForCreateProviderPlans struct {
	rows                 []CreateProviderPlansParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateProviderPlans) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateProviderPlans) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].ProviderID,
		r.rows[0].Name,
		r.rows[0].Description,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].Etag,
	}, nil
}

func (r iteratorForCreateProviderPlans) Err() error {
	return nil
}

func (q *Queries) CreateProviderPlans(ctx context.Context, arg []CreateProviderPlansParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "provider_plans"}, []string{"id", "provider_id", "name", "description", "created_at", "updated_at", "etag"}, &iteratorForCreateProviderPlans{rows: arg})
}

// iteratorForCreateProviderPrices implements pgx.CopyFromSource.
type iteratorForCreateProviderPrices struct {
	rows                 []CreateProviderPricesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateProviderPrices) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateProviderPrices) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].PlanID,
		r.rows[0].Currency,
		r.rows[0].Amount,
		r.rows[0].StartDate,
		r.rows[0].EndDate,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].Etag,
	}, nil
}

func (r iteratorForCreateProviderPrices) Err() error {
	return nil
}

func (q *Queries) CreateProviderPrices(ctx context.Context, arg []CreateProviderPricesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "provider_prices"}, []string{"id", "plan_id", "currency", "amount", "start_date", "end_date", "created_at", "updated_at", "etag"}, &iteratorForCreateProviderPrices{rows: arg})
}

// iteratorForCreateProviders implements pgx.CopyFromSource.
type iteratorForCreateProviders struct {
	rows                 []CreateProvidersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateProviders) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateProviders) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].OwnerType,
		r.rows[0].OwnerFamilyID,
		r.rows[0].OwnerUserID,
		r.rows[0].Name,
		r.rows[0].Key,
		r.rows[0].Description,
		r.rows[0].IconUrl,
		r.rows[0].Url,
		r.rows[0].PricingPageUrl,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].Etag,
	}, nil
}

func (r iteratorForCreateProviders) Err() error {
	return nil
}

func (q *Queries) CreateProviders(ctx context.Context, arg []CreateProvidersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "providers"}, []string{"id", "owner_type", "owner_family_id", "owner_user_id", "name", "key", "description", "icon_url", "url", "pricing_page_url", "created_at", "updated_at", "etag"}, &iteratorForCreateProviders{rows: arg})
}

// iteratorForCreateSubscriptionServiceUsers implements pgx.CopyFromSource.
type iteratorForCreateSubscriptionServiceUsers struct {
	rows                 []CreateSubscriptionServiceUsersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateSubscriptionServiceUsers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateSubscriptionServiceUsers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SubscriptionID,
		r.rows[0].FamilyMemberID,
	}, nil
}

func (r iteratorForCreateSubscriptionServiceUsers) Err() error {
	return nil
}

func (q *Queries) CreateSubscriptionServiceUsers(ctx context.Context, arg []CreateSubscriptionServiceUsersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "subscription_service_users"}, []string{"subscription_id", "family_member_id"}, &iteratorForCreateSubscriptionServiceUsers{rows: arg})
}

// iteratorForCreateSubscriptions implements pgx.CopyFromSource.
type iteratorForCreateSubscriptions struct {
	rows                 []CreateSubscriptionsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateSubscriptions) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateSubscriptions) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].FriendlyName,
		r.rows[0].FreeTrialStartDate,
		r.rows[0].FreeTrialEndDate,
		r.rows[0].ProviderID,
		r.rows[0].PlanID,
		r.rows[0].PriceID,
		r.rows[0].CustomPriceCurrency,
		r.rows[0].CustomPriceAmount,
		r.rows[0].OwnerType,
		r.rows[0].OwnerFamilyID,
		r.rows[0].OwnerUserID,
		r.rows[0].PayerType,
		r.rows[0].FamilyID,
		r.rows[0].PayerMemberID,
		r.rows[0].StartDate,
		r.rows[0].EndDate,
		r.rows[0].Recurrency,
		r.rows[0].CustomRecurrency,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].Etag,
	}, nil
}

func (r iteratorForCreateSubscriptions) Err() error {
	return nil
}

func (q *Queries) CreateSubscriptions(ctx context.Context, arg []CreateSubscriptionsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"public", "subscriptions"}, []string{"id", "friendly_name", "free_trial_start_date", "free_trial_end_date", "provider_id", "plan_id", "price_id", "custom_price_currency", "custom_price_amount", "owner_type", "owner_family_id", "owner_user_id", "payer_type", "family_id", "payer_member_id", "start_date", "end_date", "recurrency", "custom_recurrency", "created_at", "updated_at", "etag"}, &iteratorForCreateSubscriptions{rows: arg})
}
