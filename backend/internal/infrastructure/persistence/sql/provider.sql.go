// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: provider.sql

package sql

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createProvider = `-- name: CreateProvider :exec
INSERT INTO public.providers (id, owner_type, owner_family_id,
                              owner_user_id, name, key,
                              description, icon_url, url,
                              pricing_page_url, created_at, updated_at,
                              etag)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type CreateProviderParams struct {
	ID             uuid.UUID
	OwnerType      string
	OwnerFamilyID  *uuid.UUID
	OwnerUserID    *string
	Name           string
	Key            *string
	Description    *string
	IconUrl        *string
	Url            *string
	PricingPageUrl *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Etag           string
}

func (q *Queries) CreateProvider(ctx context.Context, arg CreateProviderParams) error {
	_, err := q.db.Exec(ctx, createProvider,
		arg.ID,
		arg.OwnerType,
		arg.OwnerFamilyID,
		arg.OwnerUserID,
		arg.Name,
		arg.Key,
		arg.Description,
		arg.IconUrl,
		arg.Url,
		arg.PricingPageUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

const createProviderLabel = `-- name: CreateProviderLabel :exec
INSERT INTO public.provider_labels (label_id, provider_id)
VALUES ($1, $2)
`

type CreateProviderLabelParams struct {
	LabelID    uuid.UUID
	ProviderID uuid.UUID
}

func (q *Queries) CreateProviderLabel(ctx context.Context, arg CreateProviderLabelParams) error {
	_, err := q.db.Exec(ctx, createProviderLabel, arg.LabelID, arg.ProviderID)
	return err
}

type CreateProviderLabelsParams struct {
	LabelID    uuid.UUID
	ProviderID uuid.UUID
}

const createProviderPlan = `-- name: CreateProviderPlan :exec
INSERT INTO public.provider_plans (id, provider_id, name,
                                   description, created_at, updated_at,
                                   etag)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateProviderPlanParams struct {
	ID          uuid.UUID
	ProviderID  uuid.UUID
	Name        string
	Description *string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Etag        string
}

func (q *Queries) CreateProviderPlan(ctx context.Context, arg CreateProviderPlanParams) error {
	_, err := q.db.Exec(ctx, createProviderPlan,
		arg.ID,
		arg.ProviderID,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

type CreateProviderPlansParams struct {
	ID          uuid.UUID
	ProviderID  uuid.UUID
	Name        string
	Description *string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Etag        string
}

const createProviderPrice = `-- name: CreateProviderPrice :exec
INSERT INTO public.provider_prices (id, plan_id, currency,
                                    amount, start_date, end_date,
                                    created_at, updated_at, etag)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateProviderPriceParams struct {
	ID        uuid.UUID
	PlanID    uuid.UUID
	Currency  string
	Amount    float64
	StartDate time.Time
	EndDate   *time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
	Etag      string
}

func (q *Queries) CreateProviderPrice(ctx context.Context, arg CreateProviderPriceParams) error {
	_, err := q.db.Exec(ctx, createProviderPrice,
		arg.ID,
		arg.PlanID,
		arg.Currency,
		arg.Amount,
		arg.StartDate,
		arg.EndDate,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

type CreateProviderPricesParams struct {
	ID        uuid.UUID
	PlanID    uuid.UUID
	Currency  string
	Amount    float64
	StartDate time.Time
	EndDate   *time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
	Etag      string
}

type CreateProvidersParams struct {
	ID             uuid.UUID
	OwnerType      string
	OwnerFamilyID  *uuid.UUID
	OwnerUserID    *string
	Name           string
	Key            *string
	Description    *string
	IconUrl        *string
	Url            *string
	PricingPageUrl *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Etag           string
}

const deleteProvider = `-- name: DeleteProvider :exec
DELETE
FROM public.providers
WHERE id = $1
`

func (q *Queries) DeleteProvider(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProvider, id)
	return err
}

const deleteProviderLabel = `-- name: DeleteProviderLabel :exec
DELETE
FROM public.provider_labels
WHERE provider_id = $1
  AND label_id = $2
`

type DeleteProviderLabelParams struct {
	ProviderID uuid.UUID
	LabelID    uuid.UUID
}

func (q *Queries) DeleteProviderLabel(ctx context.Context, arg DeleteProviderLabelParams) error {
	_, err := q.db.Exec(ctx, deleteProviderLabel, arg.ProviderID, arg.LabelID)
	return err
}

const deleteProviderPlan = `-- name: DeleteProviderPlan :exec
DELETE
FROM public.provider_plans
WHERE id = $1
`

func (q *Queries) DeleteProviderPlan(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProviderPlan, id)
	return err
}

const deleteProviderPrice = `-- name: DeleteProviderPrice :exec
DELETE
FROM public.provider_prices
WHERE id = $1
`

func (q *Queries) DeleteProviderPrice(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProviderPrice, id)
	return err
}

const isProviderExists = `-- name: IsProviderExists :one
SELECT COUNT(*)
FROM public.providers p
WHERE p.id = ANY ($1::uuid[])
`

func (q *Queries) IsProviderExists(ctx context.Context, dollar_1 []uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, isProviderExists, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateProvider = `-- name: UpdateProvider :exec
UPDATE public.providers
SET owner_type       = $2,
    owner_family_id  = $3,
    owner_user_id    = $4,
    name             = $5,
    key              = $6,
    description      = $7,
    icon_url         = $8,
    url              = $9,
    pricing_page_url = $10,
    updated_at       = $11
WHERE id = $1
`

type UpdateProviderParams struct {
	ID             uuid.UUID
	OwnerType      string
	OwnerFamilyID  *uuid.UUID
	OwnerUserID    *string
	Name           string
	Key            *string
	Description    *string
	IconUrl        *string
	Url            *string
	PricingPageUrl *string
	UpdatedAt      time.Time
}

func (q *Queries) UpdateProvider(ctx context.Context, arg UpdateProviderParams) error {
	_, err := q.db.Exec(ctx, updateProvider,
		arg.ID,
		arg.OwnerType,
		arg.OwnerFamilyID,
		arg.OwnerUserID,
		arg.Name,
		arg.Key,
		arg.Description,
		arg.IconUrl,
		arg.Url,
		arg.PricingPageUrl,
		arg.UpdatedAt,
	)
	return err
}

const updateProviderPlan = `-- name: UpdateProviderPlan :exec
UPDATE public.provider_plans
SET name        = $2,
    description = $3,
    updated_at  = $4,
    etag        = $5,
    provider_id = $6
WHERE id = $1
`

type UpdateProviderPlanParams struct {
	ID          uuid.UUID
	Name        string
	Description *string
	UpdatedAt   time.Time
	Etag        string
	ProviderID  uuid.UUID
}

func (q *Queries) UpdateProviderPlan(ctx context.Context, arg UpdateProviderPlanParams) error {
	_, err := q.db.Exec(ctx, updateProviderPlan,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
		arg.Etag,
		arg.ProviderID,
	)
	return err
}

const updateProviderPrice = `-- name: UpdateProviderPrice :exec
UPDATE public.provider_prices
SET currency   = $2,
    amount     = $3,
    start_date = $4,
    end_date   = $5,
    updated_at = $6,
    etag       = $7,
    plan_id    = $8
WHERE id = $1
`

type UpdateProviderPriceParams struct {
	ID        uuid.UUID
	Currency  string
	Amount    float64
	StartDate time.Time
	EndDate   *time.Time
	UpdatedAt time.Time
	Etag      string
	PlanID    uuid.UUID
}

func (q *Queries) UpdateProviderPrice(ctx context.Context, arg UpdateProviderPriceParams) error {
	_, err := q.db.Exec(ctx, updateProviderPrice,
		arg.ID,
		arg.Currency,
		arg.Amount,
		arg.StartDate,
		arg.EndDate,
		arg.UpdatedAt,
		arg.Etag,
		arg.PlanID,
	)
	return err
}

const getProviderById = `-- name: getProviderById :many
SELECT p.id               AS "providers.id",
       p.owner_type       AS "providers.owner_type",
       p.owner_family_id  AS "providers.owner_family_id",
       p.owner_user_id    AS "providers.owner_user_id",
       p.name             AS "providers.name",
       p.key              AS "providers.key",
       p.description      AS "providers.description",
       p.icon_url         AS "providers.icon_url",
       p.url              AS "providers.url",
       p.pricing_page_url AS "providers.pricing_page_url",
       p.created_at       AS "providers.created_at",
       p.updated_at       AS "providers.updated_at",
       p.etag             AS "providers.etag",
       ppl.id             AS "provider_plans.id",
       ppl.name           AS "provider_plans.name",
       ppl.description    AS "provider_plans.description",
       ppl.provider_id    AS "provider_plans.provider_id",
       ppl.created_at     AS "provider_plans.created_at",
       ppl.updated_at     AS "provider_plans.updated_at",
       ppl.etag           AS "provider_plans.etag",
       ppr.id             AS "provider_prices.id",
       ppr.start_date     AS "provider_prices.start_date",
       ppr.end_date       AS "provider_prices.end_date",
       ppr.currency       AS "provider_prices.currency",
       ppr.amount         AS "provider_prices.amount",
       ppr.plan_id        AS "provider_prices.plan_id",
       ppr.created_at     AS "provider_prices.created_at",
       ppr.updated_at     AS "provider_prices.updated_at",
       ppr.etag           AS "provider_prices.etag",
       pl.label_id        AS "provider_labels.label_id",
       pl.provider_id     AS "provider_labels.provider_id"
FROM public.providers p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
         LEFT JOIN public.provider_labels pl ON pl.provider_id = p.id
WHERE p.id = $1
`

type getProviderByIdRow struct {
	ProvidersID              uuid.UUID
	ProvidersOwnerType       string
	ProvidersOwnerFamilyID   *uuid.UUID
	ProvidersOwnerUserID     *string
	ProvidersName            string
	ProvidersKey             *string
	ProvidersDescription     *string
	ProvidersIconUrl         *string
	ProvidersUrl             *string
	ProvidersPricingPageUrl  *string
	ProvidersCreatedAt       time.Time
	ProvidersUpdatedAt       time.Time
	ProvidersEtag            string
	ProviderPlansID          *uuid.UUID
	ProviderPlansName        *string
	ProviderPlansDescription *string
	ProviderPlansProviderID  *uuid.UUID
	ProviderPlansCreatedAt   *time.Time
	ProviderPlansUpdatedAt   *time.Time
	ProviderPlansEtag        *string
	ProviderPricesID         *uuid.UUID
	ProviderPricesStartDate  *time.Time
	ProviderPricesEndDate    *time.Time
	ProviderPricesCurrency   *string
	ProviderPricesAmount     *float64
	ProviderPricesPlanID     *uuid.UUID
	ProviderPricesCreatedAt  *time.Time
	ProviderPricesUpdatedAt  *time.Time
	ProviderPricesEtag       *string
	ProviderLabelsLabelID    *uuid.UUID
	ProviderLabelsProviderID *uuid.UUID
}

func (q *Queries) getProviderById(ctx context.Context, id uuid.UUID) ([]getProviderByIdRow, error) {
	rows, err := q.db.Query(ctx, getProviderById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getProviderByIdRow
	for rows.Next() {
		var i getProviderByIdRow
		if err := rows.Scan(
			&i.ProvidersID,
			&i.ProvidersOwnerType,
			&i.ProvidersOwnerFamilyID,
			&i.ProvidersOwnerUserID,
			&i.ProvidersName,
			&i.ProvidersKey,
			&i.ProvidersDescription,
			&i.ProvidersIconUrl,
			&i.ProvidersUrl,
			&i.ProvidersPricingPageUrl,
			&i.ProvidersCreatedAt,
			&i.ProvidersUpdatedAt,
			&i.ProvidersEtag,
			&i.ProviderPlansID,
			&i.ProviderPlansName,
			&i.ProviderPlansDescription,
			&i.ProviderPlansProviderID,
			&i.ProviderPlansCreatedAt,
			&i.ProviderPlansUpdatedAt,
			&i.ProviderPlansEtag,
			&i.ProviderPricesID,
			&i.ProviderPricesStartDate,
			&i.ProviderPricesEndDate,
			&i.ProviderPricesCurrency,
			&i.ProviderPricesAmount,
			&i.ProviderPricesPlanID,
			&i.ProviderPricesCreatedAt,
			&i.ProviderPricesUpdatedAt,
			&i.ProviderPricesEtag,
			&i.ProviderLabelsLabelID,
			&i.ProviderLabelsProviderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProviderByIdForUser = `-- name: getProviderByIdForUser :many
SELECT p.id               AS "providers.id",
       p.owner_type       AS "providers.owner_type",
       p.owner_family_id  AS "providers.owner_family_id",
       p.owner_user_id    AS "providers.owner_user_id",
       p.name             AS "providers.name",
       p.key              AS "providers.key",
       p.description      AS "providers.description",
       p.icon_url         AS "providers.icon_url",
       p.url              AS "providers.url",
       p.pricing_page_url AS "providers.pricing_page_url",
       p.created_at       AS "providers.created_at",
       p.updated_at       AS "providers.updated_at",
       p.etag             AS "providers.etag",
       ppl.id             AS "provider_plans.id",
       ppl.name           AS "provider_plans.name",
       ppl.description    AS "provider_plans.description",
       ppl.provider_id    AS "provider_plans.provider_id",
       ppl.created_at     AS "provider_plans.created_at",
       ppl.updated_at     AS "provider_plans.updated_at",
       ppl.etag           AS "provider_plans.etag",
       ppr.id             AS "provider_prices.id",
       ppr.start_date     AS "provider_prices.start_date",
       ppr.end_date       AS "provider_prices.end_date",
       ppr.currency       AS "provider_prices.currency",
       ppr.amount         AS "provider_prices.amount",
       ppr.plan_id        AS "provider_prices.plan_id",
       ppr.created_at     AS "provider_prices.created_at",
       ppr.updated_at     AS "provider_prices.updated_at",
       ppr.etag           AS "provider_prices.etag",
       pl.label_id        AS "provider_labels.label_id",
       pl.provider_id     AS "provider_labels.provider_id"
FROM public.providers p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
         LEFT JOIN public.provider_labels pl ON pl.provider_id = p.id
         LEFT JOIN public.families f ON f.id = p.owner_family_id
         LEFT JOIN public.family_members fm ON fm.family_id = f.id
WHERE p.id = $1
  AND (
    p.owner_type = 'system' OR
    (p.owner_type = 'personal' AND p.owner_user_id = $2) OR
    (p.owner_type = 'family' AND fm.user_id = $2)
    )
`

type getProviderByIdForUserParams struct {
	ID          uuid.UUID
	OwnerUserID *string
}

type getProviderByIdForUserRow struct {
	ProvidersID              uuid.UUID
	ProvidersOwnerType       string
	ProvidersOwnerFamilyID   *uuid.UUID
	ProvidersOwnerUserID     *string
	ProvidersName            string
	ProvidersKey             *string
	ProvidersDescription     *string
	ProvidersIconUrl         *string
	ProvidersUrl             *string
	ProvidersPricingPageUrl  *string
	ProvidersCreatedAt       time.Time
	ProvidersUpdatedAt       time.Time
	ProvidersEtag            string
	ProviderPlansID          *uuid.UUID
	ProviderPlansName        *string
	ProviderPlansDescription *string
	ProviderPlansProviderID  *uuid.UUID
	ProviderPlansCreatedAt   *time.Time
	ProviderPlansUpdatedAt   *time.Time
	ProviderPlansEtag        *string
	ProviderPricesID         *uuid.UUID
	ProviderPricesStartDate  *time.Time
	ProviderPricesEndDate    *time.Time
	ProviderPricesCurrency   *string
	ProviderPricesAmount     *float64
	ProviderPricesPlanID     *uuid.UUID
	ProviderPricesCreatedAt  *time.Time
	ProviderPricesUpdatedAt  *time.Time
	ProviderPricesEtag       *string
	ProviderLabelsLabelID    *uuid.UUID
	ProviderLabelsProviderID *uuid.UUID
}

func (q *Queries) getProviderByIdForUser(ctx context.Context, arg getProviderByIdForUserParams) ([]getProviderByIdForUserRow, error) {
	rows, err := q.db.Query(ctx, getProviderByIdForUser, arg.ID, arg.OwnerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getProviderByIdForUserRow
	for rows.Next() {
		var i getProviderByIdForUserRow
		if err := rows.Scan(
			&i.ProvidersID,
			&i.ProvidersOwnerType,
			&i.ProvidersOwnerFamilyID,
			&i.ProvidersOwnerUserID,
			&i.ProvidersName,
			&i.ProvidersKey,
			&i.ProvidersDescription,
			&i.ProvidersIconUrl,
			&i.ProvidersUrl,
			&i.ProvidersPricingPageUrl,
			&i.ProvidersCreatedAt,
			&i.ProvidersUpdatedAt,
			&i.ProvidersEtag,
			&i.ProviderPlansID,
			&i.ProviderPlansName,
			&i.ProviderPlansDescription,
			&i.ProviderPlansProviderID,
			&i.ProviderPlansCreatedAt,
			&i.ProviderPlansUpdatedAt,
			&i.ProviderPlansEtag,
			&i.ProviderPricesID,
			&i.ProviderPricesStartDate,
			&i.ProviderPricesEndDate,
			&i.ProviderPricesCurrency,
			&i.ProviderPricesAmount,
			&i.ProviderPricesPlanID,
			&i.ProviderPricesCreatedAt,
			&i.ProviderPricesUpdatedAt,
			&i.ProviderPricesEtag,
			&i.ProviderLabelsLabelID,
			&i.ProviderLabelsProviderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProviders = `-- name: getProviders :many
SELECT p.id               AS "providers.id",
       p.owner_type       AS "providers.owner_type",
       p.owner_family_id  AS "providers.owner_family_id",
       p.owner_user_id    AS "providers.owner_user_id",
       p.name             AS "providers.name",
       p.key              AS "providers.key",
       p.description      AS "providers.description",
       p.icon_url         AS "providers.icon_url",
       p.url              AS "providers.url",
       p.pricing_page_url AS "providers.pricing_page_url",
       p.created_at       AS "providers.created_at",
       p.updated_at       AS "providers.updated_at",
       p.etag             AS "providers.etag",
       ppl.id             AS "provider_plans.id",
       ppl.name           AS "provider_plans.name",
       ppl.description    AS "provider_plans.description",
       ppl.provider_id    AS "provider_plans.provider_id",
       ppl.created_at     AS "provider_plans.created_at",
       ppl.updated_at     AS "provider_plans.updated_at",
       ppl.etag           AS "provider_plans.etag",
       ppr.id             AS "provider_prices.id",
       ppr.start_date     AS "provider_prices.start_date",
       ppr.end_date       AS "provider_prices.end_date",
       ppr.currency       AS "provider_prices.currency",
       ppr.amount         AS "provider_prices.amount",
       ppr.plan_id        AS "provider_prices.plan_id",
       ppr.created_at     AS "provider_prices.created_at",
       ppr.updated_at     AS "provider_prices.updated_at",
       ppr.etag           AS "provider_prices.etag",
       pl.label_id        AS "provider_labels.label_id",
       pl.provider_id     AS "provider_labels.provider_id",
       p.total_count      AS "total_count"
FROM (SELECT id, owner_type, owner_family_id, owner_user_id, name, key, description, icon_url, url, pricing_page_url, created_at, updated_at, etag,
             COUNT(*) OVER () AS total_count
      FROM public.providers
      ORDER BY id
      LIMIT $1 OFFSET $2) p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
         LEFT JOIN public.provider_labels pl ON pl.provider_id = p.id
`

type getProvidersParams struct {
	Limit  int32
	Offset int32
}

type getProvidersRow struct {
	ProvidersID              uuid.UUID
	ProvidersOwnerType       string
	ProvidersOwnerFamilyID   *uuid.UUID
	ProvidersOwnerUserID     *string
	ProvidersName            string
	ProvidersKey             *string
	ProvidersDescription     *string
	ProvidersIconUrl         *string
	ProvidersUrl             *string
	ProvidersPricingPageUrl  *string
	ProvidersCreatedAt       time.Time
	ProvidersUpdatedAt       time.Time
	ProvidersEtag            string
	ProviderPlansID          *uuid.UUID
	ProviderPlansName        *string
	ProviderPlansDescription *string
	ProviderPlansProviderID  *uuid.UUID
	ProviderPlansCreatedAt   *time.Time
	ProviderPlansUpdatedAt   *time.Time
	ProviderPlansEtag        *string
	ProviderPricesID         *uuid.UUID
	ProviderPricesStartDate  *time.Time
	ProviderPricesEndDate    *time.Time
	ProviderPricesCurrency   *string
	ProviderPricesAmount     *float64
	ProviderPricesPlanID     *uuid.UUID
	ProviderPricesCreatedAt  *time.Time
	ProviderPricesUpdatedAt  *time.Time
	ProviderPricesEtag       *string
	ProviderLabelsLabelID    *uuid.UUID
	ProviderLabelsProviderID *uuid.UUID
	TotalCount               int64
}

func (q *Queries) getProviders(ctx context.Context, arg getProvidersParams) ([]getProvidersRow, error) {
	rows, err := q.db.Query(ctx, getProviders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getProvidersRow
	for rows.Next() {
		var i getProvidersRow
		if err := rows.Scan(
			&i.ProvidersID,
			&i.ProvidersOwnerType,
			&i.ProvidersOwnerFamilyID,
			&i.ProvidersOwnerUserID,
			&i.ProvidersName,
			&i.ProvidersKey,
			&i.ProvidersDescription,
			&i.ProvidersIconUrl,
			&i.ProvidersUrl,
			&i.ProvidersPricingPageUrl,
			&i.ProvidersCreatedAt,
			&i.ProvidersUpdatedAt,
			&i.ProvidersEtag,
			&i.ProviderPlansID,
			&i.ProviderPlansName,
			&i.ProviderPlansDescription,
			&i.ProviderPlansProviderID,
			&i.ProviderPlansCreatedAt,
			&i.ProviderPlansUpdatedAt,
			&i.ProviderPlansEtag,
			&i.ProviderPricesID,
			&i.ProviderPricesStartDate,
			&i.ProviderPricesEndDate,
			&i.ProviderPricesCurrency,
			&i.ProviderPricesAmount,
			&i.ProviderPricesPlanID,
			&i.ProviderPricesCreatedAt,
			&i.ProviderPricesUpdatedAt,
			&i.ProviderPricesEtag,
			&i.ProviderLabelsLabelID,
			&i.ProviderLabelsProviderID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProvidersForUser = `-- name: getProvidersForUser :many
SELECT p.id               AS "providers.id",
       p.owner_type       AS "providers.owner_type",
       p.owner_family_id  AS "providers.owner_family_id",
       p.owner_user_id    AS "providers.owner_user_id",
       p.name             AS "providers.name",
       p.key              AS "providers.key",
       p.description      AS "providers.description",
       p.icon_url         AS "providers.icon_url",
       p.url              AS "providers.url",
       p.pricing_page_url AS "providers.pricing_page_url",
       p.created_at       AS "providers.created_at",
       p.updated_at       AS "providers.updated_at",
       p.etag             AS "providers.etag",
       ppl.id             AS "provider_plans.id",
       ppl.name           AS "provider_plans.name",
       ppl.description    AS "provider_plans.description",
       ppl.provider_id    AS "provider_plans.provider_id",
       ppl.created_at     AS "provider_plans.created_at",
       ppl.updated_at     AS "provider_plans.updated_at",
       ppl.etag           AS "provider_plans.etag",
       ppr.id             AS "provider_prices.id",
       ppr.start_date     AS "provider_prices.start_date",
       ppr.end_date       AS "provider_prices.end_date",
       ppr.currency       AS "provider_prices.currency",
       ppr.amount         AS "provider_prices.amount",
       ppr.plan_id        AS "provider_prices.plan_id",
       ppr.created_at     AS "provider_prices.created_at",
       ppr.updated_at     AS "provider_prices.updated_at",
       ppr.etag           AS "provider_prices.etag",
       pl.label_id        AS "provider_labels.label_id",
       pl.provider_id     AS "provider_labels.provider_id",
       p.total_count      AS "total_count"
FROM (SELECT p.id, p.owner_type, p.owner_family_id, p.owner_user_id, p.name, p.key, p.description, p.icon_url, p.url, p.pricing_page_url, p.created_at, p.updated_at, p.etag,
             COUNT(*) OVER () AS total_count
      FROM public.providers p
               LEFT JOIN public.families f ON f.id = p.owner_family_id
               LEFT JOIN public.family_members fm ON fm.family_id = f.id
      WHERE p.owner_type = 'system'
         OR (p.owner_type = 'personal' AND p.owner_user_id = $1)
         OR (p.owner_type = 'family' AND fm.user_id = $1)
      ORDER BY p.id
      LIMIT $2 OFFSET $3) p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
         LEFT JOIN public.provider_labels pl ON pl.provider_id = p.id
`

type getProvidersForUserParams struct {
	OwnerUserID *string
	Limit       int32
	Offset      int32
}

type getProvidersForUserRow struct {
	ProvidersID              uuid.UUID
	ProvidersOwnerType       string
	ProvidersOwnerFamilyID   *uuid.UUID
	ProvidersOwnerUserID     *string
	ProvidersName            string
	ProvidersKey             *string
	ProvidersDescription     *string
	ProvidersIconUrl         *string
	ProvidersUrl             *string
	ProvidersPricingPageUrl  *string
	ProvidersCreatedAt       time.Time
	ProvidersUpdatedAt       time.Time
	ProvidersEtag            string
	ProviderPlansID          *uuid.UUID
	ProviderPlansName        *string
	ProviderPlansDescription *string
	ProviderPlansProviderID  *uuid.UUID
	ProviderPlansCreatedAt   *time.Time
	ProviderPlansUpdatedAt   *time.Time
	ProviderPlansEtag        *string
	ProviderPricesID         *uuid.UUID
	ProviderPricesStartDate  *time.Time
	ProviderPricesEndDate    *time.Time
	ProviderPricesCurrency   *string
	ProviderPricesAmount     *float64
	ProviderPricesPlanID     *uuid.UUID
	ProviderPricesCreatedAt  *time.Time
	ProviderPricesUpdatedAt  *time.Time
	ProviderPricesEtag       *string
	ProviderLabelsLabelID    *uuid.UUID
	ProviderLabelsProviderID *uuid.UUID
	TotalCount               int64
}

func (q *Queries) getProvidersForUser(ctx context.Context, arg getProvidersForUserParams) ([]getProvidersForUserRow, error) {
	rows, err := q.db.Query(ctx, getProvidersForUser, arg.OwnerUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getProvidersForUserRow
	for rows.Next() {
		var i getProvidersForUserRow
		if err := rows.Scan(
			&i.ProvidersID,
			&i.ProvidersOwnerType,
			&i.ProvidersOwnerFamilyID,
			&i.ProvidersOwnerUserID,
			&i.ProvidersName,
			&i.ProvidersKey,
			&i.ProvidersDescription,
			&i.ProvidersIconUrl,
			&i.ProvidersUrl,
			&i.ProvidersPricingPageUrl,
			&i.ProvidersCreatedAt,
			&i.ProvidersUpdatedAt,
			&i.ProvidersEtag,
			&i.ProviderPlansID,
			&i.ProviderPlansName,
			&i.ProviderPlansDescription,
			&i.ProviderPlansProviderID,
			&i.ProviderPlansCreatedAt,
			&i.ProviderPlansUpdatedAt,
			&i.ProviderPlansEtag,
			&i.ProviderPricesID,
			&i.ProviderPricesStartDate,
			&i.ProviderPricesEndDate,
			&i.ProviderPricesCurrency,
			&i.ProviderPricesAmount,
			&i.ProviderPricesPlanID,
			&i.ProviderPricesCreatedAt,
			&i.ProviderPricesUpdatedAt,
			&i.ProviderPricesEtag,
			&i.ProviderLabelsLabelID,
			&i.ProviderLabelsProviderID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProvidersForUserWithSearch = `-- name: getProvidersForUserWithSearch :many
SELECT DISTINCT p.id               AS "providers.id",
                p.owner_type       AS "providers.owner_type",
                p.owner_family_id  AS "providers.owner_family_id",
                p.owner_user_id    AS "providers.owner_user_id",
                p.name             AS "providers.name",
                p.key              AS "providers.key",
                p.description      AS "providers.description",
                p.icon_url         AS "providers.icon_url",
                p.url              AS "providers.url",
                p.pricing_page_url AS "providers.pricing_page_url",
                p.created_at       AS "providers.created_at",
                p.updated_at       AS "providers.updated_at",
                p.etag             AS "providers.etag",
                ppl.id             AS "provider_plans.id",
                ppl.name           AS "provider_plans.name",
                ppl.description    AS "provider_plans.description",
                ppl.provider_id    AS "provider_plans.provider_id",
                ppl.created_at     AS "provider_plans.created_at",
                ppl.updated_at     AS "provider_plans.updated_at",
                ppl.etag           AS "provider_plans.etag",
                ppr.id             AS "provider_prices.id",
                ppr.start_date     AS "provider_prices.start_date",
                ppr.end_date       AS "provider_prices.end_date",
                ppr.currency       AS "provider_prices.currency",
                ppr.amount         AS "provider_prices.amount",
                ppr.plan_id        AS "provider_prices.plan_id",
                ppr.created_at     AS "provider_prices.created_at",
                ppr.updated_at     AS "provider_prices.updated_at",
                ppr.etag           AS "provider_prices.etag",
                pl.label_id        AS "provider_labels.label_id",
                pl.provider_id     AS "provider_labels.provider_id",
                p.total_count      AS "total_count"
FROM (SELECT p.id, p.owner_type, p.owner_family_id, p.owner_user_id, p.name, p.key, p.description, p.icon_url, p.url, p.pricing_page_url, p.created_at, p.updated_at, p.etag,
             COUNT(*) OVER () AS total_count
      FROM public.providers p
               LEFT JOIN public.families f ON f.id = p.owner_family_id
               LEFT JOIN public.family_members fm ON fm.family_id = f.id
               LEFT JOIN public.provider_labels pl ON pl.provider_id = p.id
               LEFT JOIN public.labels l ON l.id = pl.label_id
      WHERE (p.owner_type = 'system'
          OR (p.owner_type = 'personal' AND p.owner_user_id = $1)
          OR (p.owner_type = 'family' AND fm.user_id = $1))
        AND (p.name ILIKE $2 OR l.name ILIKE $2)
      ORDER BY p.id
      LIMIT $3 OFFSET $4) p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
         LEFT JOIN public.provider_labels pl ON pl.provider_id = p.id
`

type getProvidersForUserWithSearchParams struct {
	OwnerUserID *string
	Name        string
	Limit       int32
	Offset      int32
}

type getProvidersForUserWithSearchRow struct {
	ProvidersID              uuid.UUID
	ProvidersOwnerType       string
	ProvidersOwnerFamilyID   *uuid.UUID
	ProvidersOwnerUserID     *string
	ProvidersName            string
	ProvidersKey             *string
	ProvidersDescription     *string
	ProvidersIconUrl         *string
	ProvidersUrl             *string
	ProvidersPricingPageUrl  *string
	ProvidersCreatedAt       time.Time
	ProvidersUpdatedAt       time.Time
	ProvidersEtag            string
	ProviderPlansID          *uuid.UUID
	ProviderPlansName        *string
	ProviderPlansDescription *string
	ProviderPlansProviderID  *uuid.UUID
	ProviderPlansCreatedAt   *time.Time
	ProviderPlansUpdatedAt   *time.Time
	ProviderPlansEtag        *string
	ProviderPricesID         *uuid.UUID
	ProviderPricesStartDate  *time.Time
	ProviderPricesEndDate    *time.Time
	ProviderPricesCurrency   *string
	ProviderPricesAmount     *float64
	ProviderPricesPlanID     *uuid.UUID
	ProviderPricesCreatedAt  *time.Time
	ProviderPricesUpdatedAt  *time.Time
	ProviderPricesEtag       *string
	ProviderLabelsLabelID    *uuid.UUID
	ProviderLabelsProviderID *uuid.UUID
	TotalCount               int64
}

func (q *Queries) getProvidersForUserWithSearch(ctx context.Context, arg getProvidersForUserWithSearchParams) ([]getProvidersForUserWithSearchRow, error) {
	rows, err := q.db.Query(ctx, getProvidersForUserWithSearch,
		arg.OwnerUserID,
		arg.Name,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getProvidersForUserWithSearchRow
	for rows.Next() {
		var i getProvidersForUserWithSearchRow
		if err := rows.Scan(
			&i.ProvidersID,
			&i.ProvidersOwnerType,
			&i.ProvidersOwnerFamilyID,
			&i.ProvidersOwnerUserID,
			&i.ProvidersName,
			&i.ProvidersKey,
			&i.ProvidersDescription,
			&i.ProvidersIconUrl,
			&i.ProvidersUrl,
			&i.ProvidersPricingPageUrl,
			&i.ProvidersCreatedAt,
			&i.ProvidersUpdatedAt,
			&i.ProvidersEtag,
			&i.ProviderPlansID,
			&i.ProviderPlansName,
			&i.ProviderPlansDescription,
			&i.ProviderPlansProviderID,
			&i.ProviderPlansCreatedAt,
			&i.ProviderPlansUpdatedAt,
			&i.ProviderPlansEtag,
			&i.ProviderPricesID,
			&i.ProviderPricesStartDate,
			&i.ProviderPricesEndDate,
			&i.ProviderPricesCurrency,
			&i.ProviderPricesAmount,
			&i.ProviderPricesPlanID,
			&i.ProviderPricesCreatedAt,
			&i.ProviderPricesUpdatedAt,
			&i.ProviderPricesEtag,
			&i.ProviderLabelsLabelID,
			&i.ProviderLabelsProviderID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemProviders = `-- name: getSystemProviders :many
SELECT p.id               AS "providers.id",
       p.owner_type       AS "providers.owner_type",
       p.owner_family_id  AS "providers.owner_family_id",
       p.owner_user_id    AS "providers.owner_user_id",
       p.name             AS "providers.name",
       p.key              AS "providers.key",
       p.description      AS "providers.description",
       p.icon_url         AS "providers.icon_url",
       p.url              AS "providers.url",
       p.pricing_page_url AS "providers.pricing_page_url",
       p.created_at       AS "providers.created_at",
       p.updated_at       AS "providers.updated_at",
       p.etag             AS "providers.etag",
       ppl.id             AS "provider_plans.id",
       ppl.name           AS "provider_plans.name",
       ppl.description    AS "provider_plans.description",
       ppl.provider_id    AS "provider_plans.provider_id",
       ppl.created_at     AS "provider_plans.created_at",
       ppl.updated_at     AS "provider_plans.updated_at",
       ppl.etag           AS "provider_plans.etag",
       ppr.id             AS "provider_prices.id",
       ppr.start_date     AS "provider_prices.start_date",
       ppr.end_date       AS "provider_prices.end_date",
       ppr.currency       AS "provider_prices.currency",
       ppr.amount         AS "provider_prices.amount",
       ppr.plan_id        AS "provider_prices.plan_id",
       ppr.created_at     AS "provider_prices.created_at",
       ppr.updated_at     AS "provider_prices.updated_at",
       ppr.etag           AS "provider_prices.etag",
       pl.label_id        AS "provider_labels.label_id",
       pl.provider_id     AS "provider_labels.provider_id",
       COUNT(*) OVER ()   AS total_count
FROM public.providers p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
         LEFT JOIN public.provider_labels pl ON pl.provider_id = p.id
WHERE p.owner_type = 'system'
  AND p.owner_user_id IS NULL
  AND p.owner_family_id IS NULL
`

type getSystemProvidersRow struct {
	ProvidersID              uuid.UUID
	ProvidersOwnerType       string
	ProvidersOwnerFamilyID   *uuid.UUID
	ProvidersOwnerUserID     *string
	ProvidersName            string
	ProvidersKey             *string
	ProvidersDescription     *string
	ProvidersIconUrl         *string
	ProvidersUrl             *string
	ProvidersPricingPageUrl  *string
	ProvidersCreatedAt       time.Time
	ProvidersUpdatedAt       time.Time
	ProvidersEtag            string
	ProviderPlansID          *uuid.UUID
	ProviderPlansName        *string
	ProviderPlansDescription *string
	ProviderPlansProviderID  *uuid.UUID
	ProviderPlansCreatedAt   *time.Time
	ProviderPlansUpdatedAt   *time.Time
	ProviderPlansEtag        *string
	ProviderPricesID         *uuid.UUID
	ProviderPricesStartDate  *time.Time
	ProviderPricesEndDate    *time.Time
	ProviderPricesCurrency   *string
	ProviderPricesAmount     *float64
	ProviderPricesPlanID     *uuid.UUID
	ProviderPricesCreatedAt  *time.Time
	ProviderPricesUpdatedAt  *time.Time
	ProviderPricesEtag       *string
	ProviderLabelsLabelID    *uuid.UUID
	ProviderLabelsProviderID *uuid.UUID
	TotalCount               int64
}

func (q *Queries) getSystemProviders(ctx context.Context) ([]getSystemProvidersRow, error) {
	rows, err := q.db.Query(ctx, getSystemProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getSystemProvidersRow
	for rows.Next() {
		var i getSystemProvidersRow
		if err := rows.Scan(
			&i.ProvidersID,
			&i.ProvidersOwnerType,
			&i.ProvidersOwnerFamilyID,
			&i.ProvidersOwnerUserID,
			&i.ProvidersName,
			&i.ProvidersKey,
			&i.ProvidersDescription,
			&i.ProvidersIconUrl,
			&i.ProvidersUrl,
			&i.ProvidersPricingPageUrl,
			&i.ProvidersCreatedAt,
			&i.ProvidersUpdatedAt,
			&i.ProvidersEtag,
			&i.ProviderPlansID,
			&i.ProviderPlansName,
			&i.ProviderPlansDescription,
			&i.ProviderPlansProviderID,
			&i.ProviderPlansCreatedAt,
			&i.ProviderPlansUpdatedAt,
			&i.ProviderPlansEtag,
			&i.ProviderPricesID,
			&i.ProviderPricesStartDate,
			&i.ProviderPricesEndDate,
			&i.ProviderPricesCurrency,
			&i.ProviderPricesAmount,
			&i.ProviderPricesPlanID,
			&i.ProviderPricesCreatedAt,
			&i.ProviderPricesUpdatedAt,
			&i.ProviderPricesEtag,
			&i.ProviderLabelsLabelID,
			&i.ProviderLabelsProviderID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
