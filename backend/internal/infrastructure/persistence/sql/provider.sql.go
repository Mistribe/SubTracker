// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: provider.sql

package sql

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createProvider = `-- name: CreateProvider :exec
INSERT INTO public.providers (id, owner_type, owner_family_id,
                              owner_user_id, name, key,
                              description, icon_url, url,
                              pricing_page_url, created_at, updated_at,
                              etag)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type CreateProviderParams struct {
	ID             uuid.UUID
	OwnerType      string
	OwnerFamilyID  *uuid.UUID
	OwnerUserID    *string
	Name           string
	Key            *string
	Description    *string
	IconUrl        *string
	Url            *string
	PricingPageUrl *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Etag           string
}

func (q *Queries) CreateProvider(ctx context.Context, arg CreateProviderParams) error {
	_, err := q.db.Exec(ctx, createProvider,
		arg.ID,
		arg.OwnerType,
		arg.OwnerFamilyID,
		arg.OwnerUserID,
		arg.Name,
		arg.Key,
		arg.Description,
		arg.IconUrl,
		arg.Url,
		arg.PricingPageUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

const createProviderPlan = `-- name: CreateProviderPlan :exec
INSERT INTO public.provider_plans (id, provider_id, name,
                                   description, created_at, updated_at,
                                   etag)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateProviderPlanParams struct {
	ID          uuid.UUID
	ProviderID  uuid.UUID
	Name        string
	Description *string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Etag        string
}

func (q *Queries) CreateProviderPlan(ctx context.Context, arg CreateProviderPlanParams) error {
	_, err := q.db.Exec(ctx, createProviderPlan,
		arg.ID,
		arg.ProviderID,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

type CreateProviderPlansParams struct {
	ID          uuid.UUID
	ProviderID  uuid.UUID
	Name        string
	Description *string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Etag        string
}

const createProviderPrice = `-- name: CreateProviderPrice :exec
INSERT INTO public.provider_prices (id, plan_id, currency,
                                    amount, start_date, end_date,
                                    created_at, updated_at, etag)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateProviderPriceParams struct {
	ID        uuid.UUID
	PlanID    uuid.UUID
	Currency  string
	Amount    float64
	StartDate time.Time
	EndDate   *time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
	Etag      string
}

func (q *Queries) CreateProviderPrice(ctx context.Context, arg CreateProviderPriceParams) error {
	_, err := q.db.Exec(ctx, createProviderPrice,
		arg.ID,
		arg.PlanID,
		arg.Currency,
		arg.Amount,
		arg.StartDate,
		arg.EndDate,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Etag,
	)
	return err
}

type CreateProviderPricesParams struct {
	ID        uuid.UUID
	PlanID    uuid.UUID
	Currency  string
	Amount    float64
	StartDate time.Time
	EndDate   *time.Time
	CreatedAt time.Time
	UpdatedAt time.Time
	Etag      string
}

type CreateProvidersParams struct {
	ID             uuid.UUID
	OwnerType      string
	OwnerFamilyID  *uuid.UUID
	OwnerUserID    *string
	Name           string
	Key            *string
	Description    *string
	IconUrl        *string
	Url            *string
	PricingPageUrl *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Etag           string
}

const deleteProvider = `-- name: DeleteProvider :exec
DELETE
FROM public.providers
WHERE id = $1
`

func (q *Queries) DeleteProvider(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProvider, id)
	return err
}

const getProviderById = `-- name: GetProviderById :many
SELECT p.id, p.owner_type, p.owner_family_id, p.owner_user_id, p.name, p.key, p.description, p.icon_url, p.url, p.pricing_page_url, p.created_at, p.updated_at, p.etag,
       ppl.id, ppl.name, ppl.description, ppl.provider_id, ppl.created_at, ppl.updated_at, ppl.etag,
       ppr.id, ppr.start_date, ppr.end_date, ppr.currency, ppr.amount, ppr.plan_id, ppr.created_at, ppr.updated_at, ppr.etag
FROM public.providers p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
WHERE p.id = $1
`

type GetProviderByIdRow struct {
	Provider      Provider
	ProviderPlan  ProviderPlan
	ProviderPrice ProviderPrice
}

func (q *Queries) GetProviderById(ctx context.Context, id uuid.UUID) ([]GetProviderByIdRow, error) {
	rows, err := q.db.Query(ctx, getProviderById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProviderByIdRow
	for rows.Next() {
		var i GetProviderByIdRow
		if err := rows.Scan(
			&i.Provider.ID,
			&i.Provider.OwnerType,
			&i.Provider.OwnerFamilyID,
			&i.Provider.OwnerUserID,
			&i.Provider.Name,
			&i.Provider.Key,
			&i.Provider.Description,
			&i.Provider.IconUrl,
			&i.Provider.Url,
			&i.Provider.PricingPageUrl,
			&i.Provider.CreatedAt,
			&i.Provider.UpdatedAt,
			&i.Provider.Etag,
			&i.ProviderPlan.ID,
			&i.ProviderPlan.Name,
			&i.ProviderPlan.Description,
			&i.ProviderPlan.ProviderID,
			&i.ProviderPlan.CreatedAt,
			&i.ProviderPlan.UpdatedAt,
			&i.ProviderPlan.Etag,
			&i.ProviderPrice.ID,
			&i.ProviderPrice.StartDate,
			&i.ProviderPrice.EndDate,
			&i.ProviderPrice.Currency,
			&i.ProviderPrice.Amount,
			&i.ProviderPrice.PlanID,
			&i.ProviderPrice.CreatedAt,
			&i.ProviderPrice.UpdatedAt,
			&i.ProviderPrice.Etag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProviders = `-- name: GetProviders :many
SELECT p.id, p.owner_type, p.owner_family_id, p.owner_user_id, p.name, p.key, p.description, p.icon_url, p.url, p.pricing_page_url, p.created_at, p.updated_at, p.etag,
       ppl.id, ppl.name, ppl.description, ppl.provider_id, ppl.created_at, ppl.updated_at, ppl.etag,
       ppr.id, ppr.start_date, ppr.end_date, ppr.currency, ppr.amount, ppr.plan_id, ppr.created_at, ppr.updated_at, ppr.etag,
       COUNT() OVER () AS total_count
FROM public.providers p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
LIMIT $1 OFFSET $2
`

type GetProvidersParams struct {
	Limit  int32
	Offset int32
}

type GetProvidersRow struct {
	Provider      Provider
	ProviderPlan  ProviderPlan
	ProviderPrice ProviderPrice
	TotalCount    int64
}

func (q *Queries) GetProviders(ctx context.Context, arg GetProvidersParams) ([]GetProvidersRow, error) {
	rows, err := q.db.Query(ctx, getProviders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProvidersRow
	for rows.Next() {
		var i GetProvidersRow
		if err := rows.Scan(
			&i.Provider.ID,
			&i.Provider.OwnerType,
			&i.Provider.OwnerFamilyID,
			&i.Provider.OwnerUserID,
			&i.Provider.Name,
			&i.Provider.Key,
			&i.Provider.Description,
			&i.Provider.IconUrl,
			&i.Provider.Url,
			&i.Provider.PricingPageUrl,
			&i.Provider.CreatedAt,
			&i.Provider.UpdatedAt,
			&i.Provider.Etag,
			&i.ProviderPlan.ID,
			&i.ProviderPlan.Name,
			&i.ProviderPlan.Description,
			&i.ProviderPlan.ProviderID,
			&i.ProviderPlan.CreatedAt,
			&i.ProviderPlan.UpdatedAt,
			&i.ProviderPlan.Etag,
			&i.ProviderPrice.ID,
			&i.ProviderPrice.StartDate,
			&i.ProviderPrice.EndDate,
			&i.ProviderPrice.Currency,
			&i.ProviderPrice.Amount,
			&i.ProviderPrice.PlanID,
			&i.ProviderPrice.CreatedAt,
			&i.ProviderPrice.UpdatedAt,
			&i.ProviderPrice.Etag,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemProviders = `-- name: GetSystemProviders :many
SELECT p.id, p.owner_type, p.owner_family_id, p.owner_user_id, p.name, p.key, p.description, p.icon_url, p.url, p.pricing_page_url, p.created_at, p.updated_at, p.etag,
       ppl.id, ppl.name, ppl.description, ppl.provider_id, ppl.created_at, ppl.updated_at, ppl.etag,
       ppr.id, ppr.start_date, ppr.end_date, ppr.currency, ppr.amount, ppr.plan_id, ppr.created_at, ppr.updated_at, ppr.etag
FROM public.providers p
         LEFT JOIN public.provider_plans ppl ON ppl.provider_id = p.id
         LEFT JOIN public.provider_prices ppr ON ppl.provider_id = p.id
WHERE p.owner_type = 'system'
  AND p.owner_user_id IS NULL
  AND p.owner_family_id IS NULL
`

type GetSystemProvidersRow struct {
	Provider      Provider
	ProviderPlan  ProviderPlan
	ProviderPrice ProviderPrice
}

func (q *Queries) GetSystemProviders(ctx context.Context) ([]GetSystemProvidersRow, error) {
	rows, err := q.db.Query(ctx, getSystemProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSystemProvidersRow
	for rows.Next() {
		var i GetSystemProvidersRow
		if err := rows.Scan(
			&i.Provider.ID,
			&i.Provider.OwnerType,
			&i.Provider.OwnerFamilyID,
			&i.Provider.OwnerUserID,
			&i.Provider.Name,
			&i.Provider.Key,
			&i.Provider.Description,
			&i.Provider.IconUrl,
			&i.Provider.Url,
			&i.Provider.PricingPageUrl,
			&i.Provider.CreatedAt,
			&i.Provider.UpdatedAt,
			&i.Provider.Etag,
			&i.ProviderPlan.ID,
			&i.ProviderPlan.Name,
			&i.ProviderPlan.Description,
			&i.ProviderPlan.ProviderID,
			&i.ProviderPlan.CreatedAt,
			&i.ProviderPlan.UpdatedAt,
			&i.ProviderPlan.Etag,
			&i.ProviderPrice.ID,
			&i.ProviderPrice.StartDate,
			&i.ProviderPrice.EndDate,
			&i.ProviderPrice.Currency,
			&i.ProviderPrice.Amount,
			&i.ProviderPrice.PlanID,
			&i.ProviderPrice.CreatedAt,
			&i.ProviderPrice.UpdatedAt,
			&i.ProviderPrice.Etag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProvider = `-- name: UpdateProvider :exec
UPDATE public.providers
SET owner_type       = $2,
    owner_family_id  = $3,
    owner_user_id    = $4,
    name             = $5,
    key              = $6,
    description      = $7,
    icon_url         = $8,
    url              = $9,
    pricing_page_url = $10,
    updated_at       = $11
WHERE id = $1
`

type UpdateProviderParams struct {
	ID             uuid.UUID
	OwnerType      string
	OwnerFamilyID  *uuid.UUID
	OwnerUserID    *string
	Name           string
	Key            *string
	Description    *string
	IconUrl        *string
	Url            *string
	PricingPageUrl *string
	UpdatedAt      time.Time
}

func (q *Queries) UpdateProvider(ctx context.Context, arg UpdateProviderParams) error {
	_, err := q.db.Exec(ctx, updateProvider,
		arg.ID,
		arg.OwnerType,
		arg.OwnerFamilyID,
		arg.OwnerUserID,
		arg.Name,
		arg.Key,
		arg.Description,
		arg.IconUrl,
		arg.Url,
		arg.PricingPageUrl,
		arg.UpdatedAt,
	)
	return err
}

const updateProviderPlan = `-- name: UpdateProviderPlan :exec
UPDATE public.provider_plans
SET name        = $2,
    description = $3,
    updated_at  = $4,
    etag        = $5,
    provider_id = $6
WHERE id = $1
`

type UpdateProviderPlanParams struct {
	ID          uuid.UUID
	Name        string
	Description *string
	UpdatedAt   time.Time
	Etag        string
	ProviderID  uuid.UUID
}

func (q *Queries) UpdateProviderPlan(ctx context.Context, arg UpdateProviderPlanParams) error {
	_, err := q.db.Exec(ctx, updateProviderPlan,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
		arg.Etag,
		arg.ProviderID,
	)
	return err
}

const updateProviderPrice = `-- name: UpdateProviderPrice :exec
UPDATE public.provider_prices
SET currency   = $2,
    amount     = $3,
    start_date = $4,
    end_date   = $5,
    updated_at = $6,
    etag       = $7,
    plan_id    = $8
WHERE id = $1
`

type UpdateProviderPriceParams struct {
	ID        uuid.UUID
	Currency  string
	Amount    float64
	StartDate time.Time
	EndDate   *time.Time
	UpdatedAt time.Time
	Etag      string
	PlanID    uuid.UUID
}

func (q *Queries) UpdateProviderPrice(ctx context.Context, arg UpdateProviderPriceParams) error {
	_, err := q.db.Exec(ctx, updateProviderPrice,
		arg.ID,
		arg.Currency,
		arg.Amount,
		arg.StartDate,
		arg.EndDate,
		arg.UpdatedAt,
		arg.Etag,
		arg.PlanID,
	)
	return err
}
